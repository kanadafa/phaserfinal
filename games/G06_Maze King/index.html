<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>éŠæˆ²</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <style>
        /* ç§»é™¤æ‰€æœ‰é‚Šè·å’Œç•™ç™½ï¼Œè®“éŠæˆ²ä½”æ»¿æ•´å€‹è¦–çª— */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden; /* é˜²æ­¢æ»¾å‹•æ¢å‡ºç¾ */
            background-color: #000; /* è¨­ç½®é»‘è‰²èƒŒæ™¯ */
        }
        
        canvas {
            display: block;
            width: 100vw !important; /* å¼·åˆ¶ä½”æ»¿è¦–çª—å¯¬åº¦ */
            height: 100vh !important; /* å¼·åˆ¶ä½”æ»¿è¦–çª—é«˜åº¦ */
            object-fit: cover; /* ä¿æŒæ¯”ä¾‹ä¸¦å¡«æ»¿å®¹å™¨ */
        }
    </style>
</head>
<body>
<script>
// --- å¤§å»³å ´æ™¯ LobbyScene ---
class LobbyScene extends Phaser.Scene {
    constructor() {
        super({ key: 'LobbyScene' });
    }

    preload() {
        // å¯é å…ˆè¼‰å…¥èƒŒæ™¯åœ–ç­‰è³‡æºï¼Œé¿å…åˆ‡æ›æ™‚é–ƒçˆ
        this.load.image('background2', 'maze_cover.png');
        
        this.load.image('background', 'åˆå§‹èƒŒæ™¯.png');
        // è¼‰å…¥èƒŒæ™¯éŸ³æ¨‚
        this.load.audio('bgMusic', 'videoplayback.webm');
        
        // ç²å–å¯¦éš›ç•«å¸ƒå°ºå¯¸
        const gameWidth = this.sys.game.config.width;
        const gameHeight = this.sys.game.config.height;
        
        // é¡¯ç¤ºè¼‰å…¥é€²åº¦
        let loadingText = this.add.text(gameWidth/2, gameHeight/2, 'è¼‰å…¥ä¸­...', {
            fontSize: '32px',
            fill: '#ffffff'
        }).setOrigin(0.5);
        
        // æ·»åŠ è¼‰å…¥é€²åº¦è™•ç†
        this.load.on('progress', (value) => {
            loadingText.setText(`è¼‰å…¥ä¸­: ${Math.floor(value * 100)}%`);
        });
        
        // æ·»åŠ è¼‰å…¥å®Œæˆè™•ç†
        this.load.on('complete', () => {
            loadingText.destroy();
            console.log('å¤§å»³å ´æ™¯è³‡æºè¼‰å…¥å®Œæˆ');
        });
        
        // æ·»åŠ éŒ¯èª¤è™•ç†
        this.load.on('loaderror', (fileObj) => {
            console.error('è¼‰å…¥å¤±æ•—:', fileObj.src);
            loadingText.setText(`è¼‰å…¥å¤±æ•—: ${fileObj.key}\nè«‹é‡æ–°æ•´ç†é é¢`);
            loadingText.setFill('#ff0000');
        });
    }

    create() {
        // ç²å–å¯¦éš›ç•«å¸ƒå°ºå¯¸
        const gameWidth = this.sys.game.config.width;
        const gameHeight = this.sys.game.config.height;
        
        // åŠ å…¥èƒŒæ™¯ï¼Œè®“å®ƒå¡«æ»¿æ•´å€‹ç•«å¸ƒ
        this.coverImage = this.add.image(0, 0, 'background2').setOrigin(0, 0).setDisplaySize(gameWidth, gameHeight);

        
        // åˆå§‹åŒ–èƒŒæ™¯éŸ³æ¨‚
        this.bgMusic = this.sound.add('bgMusic', {
            volume: 0.3,  // è¨­ç½®éŸ³é‡ç‚º30%
            loop: true    // å¾ªç’°æ’­æ”¾
        });
        
        // å˜—è©¦æ’­æ”¾èƒŒæ™¯éŸ³æ¨‚
        try {
            this.bgMusic.play();
            console.log('èƒŒæ™¯éŸ³æ¨‚é–‹å§‹æ’­æ”¾');
        } catch (error) {
            console.warn('èƒŒæ™¯éŸ³æ¨‚æ’­æ”¾å¤±æ•—:', error);
        }
        
        // éŠæˆ²æ¨™é¡Œ - æ ¹æ“šç•«å¸ƒå°ºå¯¸èª¿æ•´ä½ç½®
        // ç§»é™¤æˆ‘çš„ RPG éŠæˆ²æ–‡å­—
        
        // é–‹å§‹æŒ‰éˆ• - æ ¹æ“šç•«å¸ƒå°ºå¯¸èª¿æ•´ä½ç½®å’Œå¤§å°
        const startBtn = this.add.text(gameWidth / 2.15, gameHeight * 0.47, 'é€²å…¥è¿·å®®', {
    fontSize: Math.min(gameWidth, gameHeight) * 0.05 + 'px',
    fill: '#aaf0ff',
    fontFamily: 'Arial',
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    padding: { x: 40, y: 16 }
})
.setOrigin(0.5).setInteractive({ useHandCursor: true });
        
        // æŒ‰ä¸‹æŒ‰éˆ•åˆ‡æ›åˆ° GameScene
        startBtn.on('pointerdown', () => {
            this.coverImage.setVisible(false); 
            // å°‡èƒŒæ™¯éŸ³æ¨‚å‚³éçµ¦éŠæˆ²å ´æ™¯
            
            
            this.scene.start('GameScene', { bgMusic: this.bgMusic });
        });
        
        // æ·»åŠ éŸ³æ¨‚æ§åˆ¶æŒ‰éˆ•
        this.createMusicControls();
        startBtn
    .on('pointerover', () => {
        startBtn.setStyle({
            fontSize: Math.min(gameWidth, gameHeight) * 0.06 + 'px',
            fill: '#ffff99',
            backgroundColor: 'rgba(50,50,50,0.8)'
        });
        startBtn.setScale(1.05); // å­—é«”æ•´é«”æ”¾å¤§
    })
    .on('pointerout', () => {
        startBtn.setStyle({
            fontSize: Math.min(gameWidth, gameHeight) * 0.05 + 'px',
            fill: '#aaf0ff',
            backgroundColor: 'rgba(0,0,0,0.5)'
        });
        startBtn.setScale(1); // é‚„åŸå¤§å°
    })
    .on('pointerdown', () => {
        startBtn.setScale(0.95); // é»ä¸‹å»ç¨å¾®ç¸®å°
    })
    .on('pointerup', () => {
        startBtn.setScale(1); // æ”¾é–‹é‚„åŸ
        this.scene.start('GameScene'); // åˆ‡å ´æ™¯
        this.scene.stop('LobbyScene'); // é—œé–‰å°é¢
    });
    
    }
    
    // å‰µå»ºéŸ³æ¨‚æ§åˆ¶ç•Œé¢
    createMusicControls() {
        const gameWidth = this.sys.game.config.width;
        const gameHeight = this.sys.game.config.height;
        
        // éŸ³æ¨‚é–‹é—œæŒ‰éˆ• - éŸ¿æ‡‰å¼ä½ç½®
        this.musicToggleBtn = this.add.text(gameWidth * 0.06, gameHeight * 0.08, 'ğŸ”Š éŸ³æ¨‚: é–‹', {
            fontSize: Math.min(gameWidth, gameHeight) * 0.033 + 'px',
            fill: '#ffffff',
            backgroundColor: '#333333',
            padding: { x: 10, y: 5 }
        }).setOrigin(0, 0).setInteractive({ useHandCursor: true });
        
        this.musicToggleBtn.on('pointerdown', () => {
            this.toggleMusic();
        });
        
        // éŸ³é‡æ§åˆ¶èªªæ˜
        this.add.text(gameWidth * 0.06, gameHeight * 0.15, 'éŸ³é‡æ§åˆ¶: â†‘/â†“ éµ', {
            fontSize: Math.min(gameWidth, gameHeight) * 0.027 + 'px',
            fill: '#cccccc'
        }).setOrigin(0, 0);
        
        // ç•¶å‰éŸ³é‡é¡¯ç¤º
        this.volumeText = this.add.text(gameWidth * 0.06, gameHeight * 0.18, `éŸ³é‡: ${Math.floor(this.bgMusic.volume * 100)}%`, {
            fontSize: Math.min(gameWidth, gameHeight) * 0.027 + 'px',
            fill: '#ffffff'
        }).setOrigin(0, 0);
        
        // æ·»åŠ éµç›¤æ§åˆ¶
        this.upKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.UP);
        this.downKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.DOWN);
        this.mKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.M);
    }
    
    // åˆ‡æ›éŸ³æ¨‚é–‹é—œ
    toggleMusic() {
        if (this.bgMusic.isPlaying) {
            this.bgMusic.pause();
            this.musicToggleBtn.setText('ğŸ”‡ éŸ³æ¨‚: é—œ');
            console.log('èƒŒæ™¯éŸ³æ¨‚å·²æš«åœ');
        } else {
            this.bgMusic.resume();
            this.musicToggleBtn.setText('ğŸ”Š éŸ³æ¨‚: é–‹');
            console.log('èƒŒæ™¯éŸ³æ¨‚å·²æ¢å¾©');
        }
    }
    
    update() {
        // éŸ³é‡æ§åˆ¶
        if (Phaser.Input.Keyboard.JustDown(this.upKey)) {
            this.adjustVolume(0.1);
        }
        if (Phaser.Input.Keyboard.JustDown(this.downKey)) {
            this.adjustVolume(-0.1);
        }
        
        // Méµå¿«é€Ÿåˆ‡æ›éŸ³æ¨‚
        if (Phaser.Input.Keyboard.JustDown(this.mKey)) {
            this.toggleMusic();
        }
    }
    
    // èª¿æ•´éŸ³é‡
    adjustVolume(change) {
        let newVolume = this.bgMusic.volume + change;
        newVolume = Math.max(0, Math.min(1, newVolume)); // é™åˆ¶åœ¨0-1ä¹‹é–“
        this.bgMusic.setVolume(newVolume);
        this.volumeText.setText(`éŸ³é‡: ${Math.floor(newVolume * 100)}%`);
        console.log(`éŸ³é‡èª¿æ•´ç‚º: ${Math.floor(newVolume * 100)}%`);
    }
}

// --- éŠæˆ²ä¸»å ´æ™¯ GameScene ---
class GameScene extends Phaser.Scene {
    constructor() {
        super({ key: 'GameScene' });
        // é€™è£¡ä¸åˆå§‹åŒ–å±¬æ€§ï¼Œçµ±ä¸€åœ¨ create å…§
        this.resourcesLoaded = false; // æ¨™è¨˜è³‡æºæ˜¯å¦å·²è¼‰å…¥å®Œæˆ
        this.resourcesError = false;  // æ¨™è¨˜è¼‰å…¥éç¨‹ä¸­æ˜¯å¦æœ‰éŒ¯èª¤
    }
    
    // æ¥æ”¶å¾å¤§å»³å ´æ™¯å‚³éçš„æ•¸æ“š
    init(data) {
        // æ¥æ”¶èƒŒæ™¯éŸ³æ¨‚ç‰©ä»¶
        this.bgMusic = data.bgMusic || null;
        console.log('GameScene æ¥æ”¶åˆ°èƒŒæ™¯éŸ³æ¨‚:', this.bgMusic ? 'æ˜¯' : 'å¦');
    }

    preload() {
        // è¼‰å…¥æ‰€æœ‰éŠæˆ²è³‡æº
    this.load.image('background', './åˆå§‹èƒŒæ™¯.png');
    this.load.image('wall', './ç‰†å£.png');
    this.load.image('door', './é–€.png');
    this.load.image('chest', './å¯¶ç®±.png');
    this.load.image('energy', './èƒ½é‡é£²æ–™.png');
    this.load.image('slash', './åŠæ°£.png');
    this.load.spritesheet('hero', './è‹±é›„.png', { frameWidth: 64, frameHeight: 64 });
    this.load.spritesheet('slime', './å²èŠå§†æ€ªç‰©.png', { frameWidth: 64, frameHeight: 64 });
        this.load.image('boss', './å¤§BOSS.png');  // è¼‰å…¥Bossåœ–ç‰‡
        this.load.image('skill1', './æŠ€èƒ½ä¸€.png'); // è¼‰å…¥æŠ€èƒ½ä¸€åœ–ç‰‡
        this.load.image('skill2', './æŠ€èƒ½äºŒ.png'); // è¼‰å…¥æŠ€èƒ½äºŒåœ–ç‰‡
        
        // è¼‰å…¥éŸ³æ•ˆ
        this.load.audio('slashSound', './æ®åŠ.mp3'); // è¼‰å…¥æ®åŠéŸ³æ•ˆ
        this.load.audio('levelUpSound', './å‡ç´š.mp3'); // è¼‰å…¥å‡ç´šéŸ³æ•ˆ
        this.load.audio('skill1Sound', './å¤§çˆ†ç‚¸.mp3'); // è¼‰å…¥æŠ€èƒ½ä¸€éŸ³æ•ˆ
        this.load.audio('skill2Sound', './é›·å°„å…‰.mp3'); // è¼‰å…¥æŠ€èƒ½äºŒéŸ³æ•ˆ
        
        // å¦‚æœæ²’æœ‰èƒŒæ™¯éŸ³æ¨‚ï¼Œå‰‡è¼‰å…¥éŸ³æª”
        if (!this.bgMusic) {
            this.load.audio('bgMusic', 'videoplayback.webm');
        }
        
        // ç²å–å¯¦éš›ç•«å¸ƒå°ºå¯¸
        const gameWidth = this.sys.game.config.width;
        const gameHeight = this.sys.game.config.height;
        
        // é¡¯ç¤ºè¼‰å…¥é€²åº¦
        let loadingText = this.add.text(gameWidth/2, gameHeight/2, 'è¼‰å…¥ä¸­...', {
            fontSize: '32px',
            fill: '#ffffff'
        }).setOrigin(0.5);
        
        // æ·»åŠ è¼‰å…¥é€²åº¦è™•ç†
        this.load.on('progress', (value) => {
            loadingText.setText(`è¼‰å…¥ä¸­: ${Math.floor(value * 100)}%`);
        });
        
        // æ·»åŠ è¼‰å…¥å®Œæˆè™•ç†
        this.load.on('complete', () => {
            loadingText.destroy();
            console.log('æ‰€æœ‰è³‡æºè¼‰å…¥å®Œæˆ');
            this.resourcesLoaded = true; // æ¨™è¨˜è³‡æºå·²è¼‰å…¥å®Œæˆ
        });
        
        // æ·»åŠ éŒ¯èª¤è™•ç†
        this.load.on('loaderror', (fileObj) => {
            console.error('è¼‰å…¥å¤±æ•—:', fileObj.src);
            loadingText.setText(`è¼‰å…¥å¤±æ•—: ${fileObj.key}\nè«‹é‡æ–°æ•´ç†é é¢`);
            loadingText.setFill('#ff0000');
            
            // æ¨™è¨˜è¼‰å…¥éŒ¯èª¤
            this.resourcesError = true;
            
            // æ·»åŠ é‡è©¦æŒ‰éˆ•
            const retryBtn = this.add.text(gameWidth/2, gameHeight * 0.67, 'é‡æ–°æ•´ç†', { 
                fontSize: '28px', 
                fill: '#ffffff',
                backgroundColor: '#550000',
                padding: { x: 20, y: 10 }
            }).setOrigin(0.5).setInteractive();
            
            retryBtn.on('pointerdown', () => {
                // é‡æ–°è¼‰å…¥é é¢
                location.reload();
            });
        });
    }

    create() {
        // æª¢æŸ¥è³‡æºæ˜¯å¦æˆåŠŸåŠ è¼‰
        if (this.resourcesError) {
            // å¦‚æœæœ‰è¼‰å…¥éŒ¯èª¤ï¼Œä¸åˆå§‹åŒ–éŠæˆ²
            return;
        }
        
        // ç¢ºä¿è³‡æºå·²å®Œå…¨è¼‰å…¥
        if (!this.resourcesLoaded) {
            console.warn('è³‡æºå°šæœªå®Œå…¨è¼‰å…¥ï¼Œç­‰å¾…ä¸­...');
            // å»¶é² 100ms å¾Œå†æ¬¡æª¢æŸ¥
            setTimeout(() => this.create(), 100);
            return;
        }
        
        // ç²å–å¯¦éš›ç•«å¸ƒå°ºå¯¸
        const gameWidth = this.sys.game.config.width;
        const gameHeight = this.sys.game.config.height;
        
        // åˆå§‹åŒ–èƒŒæ™¯éŸ³æ¨‚ï¼ˆå¦‚æœæ²’æœ‰å¾å¤§å»³å ´æ™¯å‚³ééä¾†ï¼‰
        if (!this.bgMusic) {
            this.bgMusic = this.sound.add('bgMusic', {
                volume: 0.3,
                loop: true
            });
            
            try {
                this.bgMusic.play();
                console.log('éŠæˆ²å ´æ™¯èƒŒæ™¯éŸ³æ¨‚é–‹å§‹æ’­æ”¾');
            } catch (error) {
                console.warn('èƒŒæ™¯éŸ³æ¨‚æ’­æ”¾å¤±æ•—:', error);
            }
        } else {
            // ç¢ºä¿éŸ³æ¨‚ç¹¼çºŒæ’­æ”¾
            if (!this.bgMusic.isPlaying) {
                try {
                    this.bgMusic.resume();
                    console.log('ç¹¼çºŒæ’­æ”¾èƒŒæ™¯éŸ³æ¨‚');
                } catch (error) {
                    console.warn('æ¢å¾©èƒŒæ™¯éŸ³æ¨‚æ’­æ”¾å¤±æ•—:', error);
                }
            }
        }
        
        // è¨˜éŒ„éŠæˆ²é–‹å§‹æ™‚é–“
        this.gameStartTime = Date.now();
        
        // --- æˆ¿é–“åœ°åœ–èˆ‡åº§æ¨™ ---
        this.mapSize = 5; // 5x5 åœ°åœ–
        this.roomMap = [];
        for (let y = 0; y < this.mapSize; y++) {
            this.roomMap[y] = [];
            for (let x = 0; x < this.mapSize; x++) {
                this.roomMap[y][x] = { visited: false };
            }
        }
        this.roomX = 2; // ç©å®¶èµ·å§‹æˆ¿é–“åº§æ¨™ï¼ˆä¸­å¤®ï¼‰
        this.roomY = 2;
        this.roomMap[this.roomY][this.roomX].visited = true;
        
        // --- Boss æˆ¿é–“è¨­å®š --- 
        this.bossRoomX = 4; // Bossåœ¨å³ä¸‹è§’çš„æˆ¿é–“ (4,4)
        this.bossRoomY = 4;
        this.bossDefeated = false; // è¨˜éŒ„Bossæ˜¯å¦å·²è¢«æ“Šæ•—
        this.hasBossSpawned = false; // è¨˜éŒ„Bossæ˜¯å¦å·²ç”Ÿæˆ
        
        // --- å°åœ°åœ–ç¹ªè£½ç‰©ä»¶ ---
        this.miniMap = this.add.graphics();
        // --- å…¶é¤˜åˆå§‹åŒ– ---
        this.playerHealth = 100;
        this.lastSlimeAttackTime = 0;
        this.isGameOver = false;
        this.slimeHealth = 100;
        this.facing = 'down';
        this.failText = null;
        this.restartBtn = null;
        // åˆå§‹åŒ–æˆ¿é–“åˆ‡æ›ç‹€æ…‹
        this.isChangingRoom = false;
        // åˆå§‹åŒ–è§’è‰²å‡ç´šç³»çµ±
        this.playerLevel = 1;
        this.playerExp = 0;
        this.expToNextLevel = 100; // å‡ç´šæ‰€éœ€ç¶“é©—å€¼
        // åˆå§‹åŒ–ç©å®¶æ”»æ“ŠåŠ›
        this.playerAttack = 20;
        // è¨˜éŒ„ç•¶å‰å¯äº’å‹•çš„é–€
        this.currentDoor = null;
        // åˆå§‹åŒ–æŠ€èƒ½ç³»çµ±
        this.hasSkill1 = false; // æ˜¯å¦å·²è§£é–æŠ€èƒ½ä¸€
        this.hasSkill2 = false; // æ˜¯å¦å·²è§£é–æŠ€èƒ½äºŒ
        this.skill1Cooldown = 0; // æŠ€èƒ½ä¸€å†·å»æ™‚é–“ï¼ˆæ¯«ç§’ï¼‰
        this.skill2Cooldown = 0; // æŠ€èƒ½äºŒå†·å»æ™‚é–“ï¼ˆæ¯«ç§’ï¼‰
        this.lastSkill1Time = 0; // ä¸Šæ¬¡ä½¿ç”¨æŠ€èƒ½ä¸€çš„æ™‚é–“
        this.lastSkill2Time = 0; // ä¸Šæ¬¡ä½¿ç”¨æŠ€èƒ½äºŒçš„æ™‚é–“

        // ç¢ºä¿åˆå§‹åŒ–æ€ªç‰©çµ„
        this.slimes = this.physics.add.group();
        // åˆå§‹åŒ–æŠ€èƒ½æ•ˆæœçµ„
        this.skillEffects = this.physics.add.group();
        
        // --- å ´æ™¯ç‰©ä»¶å»ºç«‹ ---
        this.add.image(0, 0, 'background').setOrigin(0, 0).setDisplaySize(gameWidth, gameHeight);
        // ç‰†å£ - æ ¹æ“šç•«å¸ƒå°ºå¯¸èª¿æ•´
        this.walls = this.physics.add.staticGroup();
        const wallCount = Math.ceil(gameWidth / 50);
        const wallCountVertical = Math.ceil(gameHeight / 50);
        
        for (let i = 0; i < wallCount; i++) {
            this.walls.create(25 + i * 50, gameHeight - 4, 'wall').body.setSize(64, 8).setOffset(32, 60);
            this.walls.create(25 + i * 50, 4, 'wall').setRotation(Math.PI).body.setSize(64, 8).setOffset(32, 60);
        }
        
        for (let i = 0; i < wallCountVertical; i++) {
            this.walls.create(5, 5 + i * 50, 'wall').setAngle(90).body.setSize(8, 64).setOffset(60, 32);
            this.walls.create(gameWidth - 5, 5 + i * 50, 'wall').setAngle(270).body.setSize(8, 64).setOffset(60, 32);
        }
        
        // é€šé“/é–€ - ä¿®æ”¹ç‚ºç‰©ç†ç¾¤çµ„
        this.doors = this.physics.add.group();
        
        // ç©å®¶ - æ ¹æ“šç•«å¸ƒå°ºå¯¸èª¿æ•´åˆå§‹ä½ç½®
        this.player = this.physics.add.sprite(gameWidth/2, gameHeight/2, 'hero').setScale(1.4).setCollideWorldBounds(true);
        
        // èƒ½é‡é£²æ–™ - éŸ¿æ‡‰å¼ä½ç½®
        this.energyIcon = this.add.image(gameWidth * 0.94, gameHeight * 0.92, 'energy').setScale(2).setVisible(false).setInteractive();
        this.energyIcon.on('pointerdown', () => {
            if (!this.energyIcon.visible || this.isGameOver) return;
            this.useEnergyDrink();
        });
        
        // æ·»åŠ èƒ½é‡é£²æ–™æç¤º
        this.energyPrompt = this.add.text(gameWidth * 0.94, gameHeight * 0.87, 'æŒ‰ R ä½¿ç”¨', {
            fontSize: '14px',
            fill: '#ffffff',
            backgroundColor: '#000000',
            padding: { x: 5, y: 2 }
        }).setOrigin(0.5).setVisible(false);

    // å‹•ç•«
    this.anims.create({ key: 'down', frames: this.anims.generateFrameNumbers('hero', { start: 0, end: 2 }), frameRate: 10, repeat: -1 });
    this.anims.create({ key: 'left', frames: this.anims.generateFrameNumbers('hero', { start: 3, end: 5 }), frameRate: 10, repeat: -1 });
    this.anims.create({ key: 'right', frames: this.anims.generateFrameNumbers('hero', { start: 6, end: 8 }), frameRate: 10, repeat: -1 });
    this.anims.create({ key: 'up', frames: this.anims.generateFrameNumbers('hero', { start: 9, end: 11 }), frameRate: 10, repeat: -1 });
    this.anims.create({ key: 'slime_move', frames: this.anims.generateFrameNumbers('slime', { start: 0, end: 3 }), frameRate: 6, repeat: -1 });
        // è¡€é‡æ¢ - éŸ¿æ‡‰å¼ä½ç½®
        this.healthText = this.add.text(gameWidth * 0.29, gameHeight * 0.03, `HP: ${this.playerHealth}`, { fontSize: '16px', fill: '#fff' });
        this.healthBar = this.add.graphics();
        this.updateHealthBar();
        this.slimeHealthBar = this.add.graphics();
        this.updateSlimeHealthBar();
        
        // ç¶“é©—å€¼èˆ‡ç­‰ç´šé¡¯ç¤º - éŸ¿æ‡‰å¼ä½ç½®
        this.levelText = this.add.text(gameWidth * 0.025, gameHeight * 0.083, `ç­‰ç´š: ${this.playerLevel}`, { fontSize: '16px', fill: '#fff' });
        this.expText = this.add.text(gameWidth * 0.025, gameHeight * 0.117, `ç¶“é©—: ${this.playerExp}/${this.expToNextLevel}`, { fontSize: '16px', fill: '#fff' });
        this.expBar = this.add.graphics();
        this.updateExpBar();
        
        // æ”»æ“ŠåŠ›é¡¯ç¤º - éŸ¿æ‡‰å¼ä½ç½®
        this.attackText = this.add.text(gameWidth * 0.025, gameHeight * 0.183, `æ”»æ“ŠåŠ›: ${this.playerAttack}`, { fontSize: '16px', fill: '#ff9900' });
        
        // åˆå§‹åŒ–éŸ³æ•ˆ
        this.slashSound = this.sound.add('slashSound', { volume: 0.5 }); // åˆå§‹åŒ–æ®åŠéŸ³æ•ˆ
        this.levelUpSound = this.sound.add('levelUpSound', { volume: 0.6 }); // åˆå§‹åŒ–å‡ç´šéŸ³æ•ˆ
        this.skill1Sound = this.sound.add('skill1Sound', { volume: 0.5 }); // åˆå§‹åŒ–æŠ€èƒ½ä¸€éŸ³æ•ˆ
        this.skill2Sound = this.sound.add('skill2Sound', { volume: 0.5 }); // åˆå§‹åŒ–æŠ€èƒ½äºŒéŸ³æ•ˆ
        
        // åŠæ°£æ”»æ“Š 
        this.slashes = this.physics.add.group();
        this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
        this.cursors = this.input.keyboard.createCursorKeys();
        
        // æ·»åŠ æŠ€èƒ½æŒ‰éµ
        this.qKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.Q);
        this.wKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W);
        
        // æ·»åŠ  E éµç”¨æ–¼é–€äº¤äº’
        this.eKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.E);
        
        // æ·»åŠ  R éµç”¨æ–¼ä½¿ç”¨èƒ½é‡é£²æ–™
        this.rKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.R);
        
        // æ·»åŠ é–€äº¤äº’æç¤ºæ–‡æœ¬ - éŸ¿æ‡‰å¼ä½ç½®
        this.doorPrompt = this.add.text(gameWidth/2, gameHeight * 0.83, 'æŒ‰ E é€²å…¥é–€', { 
            fontSize: '18px', 
            fill: '#ffffff',
            backgroundColor: '#000000',
            padding: { x: 10, y: 5 }
        }).setOrigin(0.5).setVisible(false);
        
        // æ·»åŠ æŠ€èƒ½åœ–æ¨™å’Œå†·å»é¡¯ç¤º
        this.createSkillUI();
        
        // ç”Ÿæˆç¬¬ä¸€å€‹æˆ¿é–“å…§å®¹
        this.generateRoom(this.roomX, this.roomY);
        // ç¢ºä¿å°åœ°åœ–åœ¨ä¸€é–‹å§‹å°±é¡¯ç¤º
        this.drawMiniMap();

        // æ·»åŠ å°åœ°åœ–æ¨™é¡Œå’Œé‚Šæ¡†ï¼Œç¢ºä¿å®ƒå§‹çµ‚é¡¯ç¤ºåœ¨é ‚å±¤ - éŸ¿æ‡‰å¼ä½ç½®
        // this.add.rectangle(gameWidth * 0.856, gameHeight * 0.217, 125, 125, 0x000000, 0.7).setDepth(9);
        // this.add.text(gameWidth * 0.781, gameHeight * 0.133, 'åœ°åœ–', { fontSize: '18px', fill: '#ffffff' }).setDepth(10);
    }

    // --- æˆ¿é–“å…§å®¹éš¨æ©Ÿç”Ÿæˆ ---
    generateRoom(x, y) {
        // ç²å–å¯¦éš›ç•«å¸ƒå°ºå¯¸
        const gameWidth = this.sys.game.config.width;
        const gameHeight = this.sys.game.config.height;
        
        // è¨˜éŒ„æˆ¿é–“ç¨®å­ï¼Œç¢ºä¿ç›¸åŒåº§æ¨™ç”Ÿæˆç›¸åŒå…§å®¹
        const roomSeed = x * 100 + y;
        this.random = new Phaser.Math.RandomDataGenerator([roomSeed]);
        
        // æ¸…é™¤èˆŠæˆ¿é–“ç‰©ä»¶
        if (this.chest) this.chest.destroy();
        
        // æ¸…é™¤æ‰€æœ‰èˆŠæ€ªç‰©
        if (this.slimes) {
            // ä½¿ç”¨æ­£ç¢ºçš„ Phaser 3 API æ¸…é™¤çµ„ä¸­çš„æ‰€æœ‰å…ƒç´ 
            this.slimes.clear(true, true);
        } else {
            // å‰µå»ºæ€ªç‰©çµ„
            this.slimes = this.physics.add.group();
        }
        
        // æ¸…é™¤Boss(å¦‚æœå­˜åœ¨)
        if (this.boss) {
            this.boss.destroy();
            this.boss = null;
        }
        
        // æ¸…é™¤ä¹‹å‰çš„é–€/é€šé“
        this.doors.clear(true, true);
        
        // --- ä¿®æ­£ï¼šé‡æ–°è¨­ç½®ç©å®¶èˆ‡ç‰†å£çš„ç¢°æ’ ---
        if (this.playerWallCollider) this.playerWallCollider.destroy();
        this.playerWallCollider = this.physics.add.collider(this.player, this.walls);
        
        // æ ¹æ“šæˆ¿é–“ä½ç½®æ·»åŠ é€šé“/é–€
        this.addDoors(x, y);
        
        // åˆ¤æ–·æ˜¯å¦æ˜¯Bossæˆ¿é–“
        if (x === this.bossRoomX && y === this.bossRoomY) {
            // é€™æ˜¯Bossæˆ¿é–“ï¼Œç”ŸæˆBoss
            this.generateBossRoom();
        } else {
            // æ™®é€šæˆ¿é–“ï¼Œç”Ÿæˆæ™®é€šå…§å®¹
            this.generateNormalRoom();
        }
        
        // æ¯æ¬¡é€²å…¥æˆ¿é–“éƒ½é‡è¨­èƒ½é‡é£²æ–™
        this.energyIcon.setVisible(false);
        
        // æ¨™è¨˜æˆ¿é–“å·²æ¢ç´¢
        this.roomMap[y][x].visited = true;
        
        // æ›´æ–°å°åœ°åœ–
        this.drawMiniMap();
        
        // é¡¯ç¤ºæˆ¿é–“åº§æ¨™
        const roomCoord = this.add.text(gameWidth * 0.94, gameHeight * 0.92, `æˆ¿é–“: (${x},${y})${(x === this.bossRoomX && y === this.bossRoomY) ? ' [BOSS]' : ''}`, {
            fontSize: '16px',
            fill: '#ffffff',
            backgroundColor: '#000000',
            padding: { x: 5, y: 2 }
        }).setOrigin(0, 0);
        
        // 3ç§’å¾Œæ·¡å‡º
        this.tweens.add({
            targets: roomCoord,
            alpha: 0,
            duration: 1000,
            delay: 2000,
            onComplete: () => {
                roomCoord.destroy();
            }
        });
    }
    
    // Bossæˆ¿é–“ç”Ÿæˆ
    generateBossRoom() {
        console.log("æ­£åœ¨ç”ŸæˆBossæˆ¿é–“...");
        
        // ç²å–å¯¦éš›ç•«å¸ƒå°ºå¯¸
        const gameWidth = this.sys.game.config.width;
        const gameHeight = this.sys.game.config.height;
        
        // ç¢ºä¿Bossåªç”Ÿæˆä¸€æ¬¡
        if (this.bossDefeated) {
            console.log("Bosså·²è¢«æ“Šæ•—ï¼Œé¡¯ç¤ºå‹åˆ©æç¤º");
            // Bosså·²è¢«æ“Šæ•—ï¼Œä¸å†ç”Ÿæˆ
            const victoryMessage = this.add.text(gameWidth/2, gameHeight * 0.3, 'é€™å€‹æˆ¿é–“æ›¾ç¶“æœ‰ä¸€å€‹å¼·å¤§çš„Boss...\nä½†å·²è¢«ä½ æ“Šæ•—äº†ï¼', {
                fontSize: Math.min(gameWidth, gameHeight) * 0.08 + 'px',
                fill: '#ffff00',
                stroke: '#000000',
                strokeThickness: 4,
                align: 'center'
            }).setOrigin(0.5);
            
            // æ·»åŠ ä¸€äº›å…‰æ•ˆ
            const light = this.add.graphics();
            light.fillStyle(0xffff00, 0.2);
            light.fillCircle(gameWidth/2, gameHeight/2, 150);
            
            // ç™¼å…‰æ•ˆæœå‹•ç•«
            this.tweens.add({
                targets: light,
                alpha: 0.1,
                duration: 2000,
                yoyo: true,
                repeat: -1
            });
            
            setTimeout(() => {
                victoryMessage.destroy();
            }, 5000);
            
            return;
        }
        
        // æª¢æŸ¥Bossæ˜¯å¦å·²ç¶“å­˜åœ¨ä½†æ²’è¢«æ“Šæ•—
        if (this.hasBossSpawned) {
            console.log('Bosså·²å­˜åœ¨ï¼Œé‡æ–°åŠ è¼‰Boss');
            
            // ç¢ºä¿å…ˆæ¸…ç†ä¹‹å‰çš„Bossç›¸é—œç‰©ä»¶
            if (this.boss) {
                this.boss.destroy();
            }
            
            // æ¸…ç†è¡€æ¢
            if (this.bossHealthBar) this.bossHealthBar.clear();
            if (this.bossNameText) this.bossNameText.destroy();
            if (this.bossHealthText) this.bossHealthText.destroy();
            
            // é‡æ–°å‰µå»ºBoss
            this.boss = this.physics.add.sprite(200, 200, 'boss')
                .setScale(0.5)
                .setCollideWorldBounds(true);
            
            // é‚„åŸBosså±¬æ€§
            this.boss.bossHealth = 500 + (this.playerLevel * 50);
            this.boss.maxHealth = this.boss.bossHealth;
            this.boss.moveSpeed = 40;
            this.boss.attackPower = 12;
            this.boss.lastAttackTime = 0;
            
            // Bossèˆ‡ç‰†å£çš„ç¢°æ’
            this.physics.add.collider(this.boss, this.walls);
            
            // è¨­ç½®Bossèˆ‡ç©å®¶å’ŒåŠæ°£çš„ç¢°æ’
            this.setupBossInteractions();
            
            // æ·»åŠ Bossè¡€æ¢
            this.bossHealthBar = this.add.graphics();
            this.bossNameText = null;  // ç¢ºä¿æœƒé‡æ–°å‰µå»º
            this.bossHealthText = null;
            this.updateBossHealthBar();
            
            console.log('Bossé‡æ–°åŠ è¼‰å®Œæˆ');
            
            return;
        }
        
        console.log('é¦–æ¬¡é€²å…¥Bossæˆ¿é–“ï¼Œæ’­æ”¾ç‰¹æ•ˆ');
        // é¦–æ¬¡é€²å…¥Bossæˆ¿é–“ï¼Œæ’­æ”¾ç‰¹æ•ˆ
        this.hasBossSpawned = true; // æ¨™è¨˜Bosså·²ç”Ÿæˆ
        
        // å‰µå»ºBoss
        this.boss = this.physics.add.sprite(gameWidth/2, gameHeight/2, 'boss')
            .setScale(0.5)
            .setCollideWorldBounds(true);
            
        console.log('Bosså·²å‰µå»ºï¼Œå¤§å°ï¼š0.5');
        
        // è¨­ç½®Bosså±¬æ€§
        this.boss.bossHealth = 500 + (this.playerLevel * 50); // æ ¹æ“šç©å®¶ç­‰ç´šå¢åŠ Bossè¡€é‡
        this.boss.maxHealth = this.boss.bossHealth;
        this.boss.moveSpeed = 40;
        this.boss.attackPower = 12;
        this.boss.lastAttackTime = 0;
        
        // Bossèˆ‡ç‰†å£çš„ç¢°æ’
        this.physics.add.collider(this.boss, this.walls);
        
        // è¨­ç½®Bossèˆ‡ç©å®¶å’ŒåŠæ°£çš„ç¢°æ’
        this.setupBossInteractions();
        
        // é¡¯ç¤ºBossç™»å ´è¨Šæ¯
        this.cameras.main.flash(500, 255, 0, 0);
        this.cameras.main.shake(500, 0.05);
        
        const bossMessage = this.add.text(400, 150, 'çµ‚æ¥µBosså‡ºç¾!', {
            fontSize: '36px',
            fill: '#ff0000',
            stroke: '#000000',
            strokeThickness: 6
        }).setOrigin(0.5).setDepth(100);
        
        // æ·»åŠ Bossåç¨±æ–‡å­—
        const bossName = this.add.text(400, 200, 'æš—å½±é­”ç‹', {
            fontSize: '28px',
            fill: '#ff9900',
            stroke: '#000000',
            strokeThickness: 4
        }).setOrigin(0.5).setDepth(100);
        
        // æ·»åŠ ä¸€äº›å…¥å ´ç‰¹æ•ˆ
        const ring = this.add.graphics();
        ring.lineStyle(5, 0xff0000, 1);
        ring.strokeCircle(gameWidth/2, gameHeight/2, 150);
        
        this.tweens.add({
            targets: ring,
            scaleX: 0.1,
            scaleY: 0.1,
            alpha: 0,
            duration: 1000,
            ease: 'Power2',
            onComplete: () => {
                ring.destroy();
            }
        });
        
        setTimeout(() => {
            bossMessage.destroy();
            bossName.destroy();
        }, 3000);
        
        // æ·»åŠ Bossè¡€æ¢
        this.bossHealthBar = this.add.graphics();
        this.updateBossHealthBar();
        
        console.log('Bossç”Ÿæˆå®Œæˆï¼Œè¡€é‡ï¼š' + this.boss.bossHealth);
    }
    
    // Bossèˆ‡ç©å®¶å’ŒåŠæ°£çš„ç¢°æ’è¨­ç½®ï¼Œæå–ç‚ºå–®ç¨æ–¹æ³•
    setupBossInteractions() {
        console.log("è¨­ç½®Bossäº¤äº’...");
        
        // å…ˆç§»é™¤ä¹‹å‰å¯èƒ½å­˜åœ¨çš„é‡è¤‡ç¢°æ’æª¢æ¸¬
        this.physics.world.colliders.getActive()
            .filter(collider => 
                (collider.object1 === this.player && collider.object2 === this.boss) || 
                (collider.object1 === this.boss && collider.object2 === this.player) ||
                (collider.object1 === this.slashes && collider.object2 === this.boss) ||
                (collider.object1 === this.boss && collider.object2 === this.slashes)
            )
            .forEach(collider => collider.destroy());
        
        // Bossèˆ‡ç©å®¶çš„ç¢°æ’
        this.physics.add.overlap(this.player, this.boss, () => {
            if (this.isGameOver) return;
            
            const now = this.time.now;
            if (now - this.boss.lastAttackTime >= 1000) {
                // Bossæ”»æ“Šç©å®¶
                this.playerHealth -= this.boss.attackPower;
                if (this.playerHealth < 0) this.playerHealth = 0;
                this.updateHealthBar();
                this.boss.lastAttackTime = now;
                
                // é¡¯ç¤ºå—å‚·æ•ˆæœ
                this.cameras.main.flash(300, 255, 0, 0, true);
                
                // é¡¯ç¤ºå‚·å®³æ–‡å­—
                const damageText = this.add.text(this.player.x, this.player.y - 40, `-${this.boss.attackPower}`, { 
                    fontSize: '24px', 
                    fill: '#ff0000',
                    fontStyle: 'bold',
                    stroke: '#000000',
                    strokeThickness: 4
                }).setOrigin(0.5);
                
                this.tweens.add({
                    targets: damageText,
                    y: damageText.y - 40,
                    alpha: 0,
                    duration: 800,
                    onComplete: () => {
                        damageText.destroy();
                    }
                });
                
                // Bossæ”»æ“Šå‹•ç•«
                this.tweens.add({
                    targets: this.boss,
                    x: this.player.x,
                    y: this.player.y,
                    duration: 150,
                    yoyo: true,
                    ease: 'Power2'
                });
                
                if (this.playerHealth === 0) {
                    this.isGameOver = true;
                    this.player.setTint(0xff0000);
                    this.player.anims.stop();
                    this.showGameOverUI();
                }
            }
        });
        
        // åŠæ°£èˆ‡Bossçš„ç¢°æ’
        this.physics.add.overlap(this.slashes, this.boss, (boss, slash) => {
        slash.destroy();
            
            // é€ æˆå‚·å®³(å°Bosså‚·å®³é™ä½50%)
            let damage = Math.floor(this.playerAttack * 0.5);
            this.boss.bossHealth -= damage;
            console.log(`Bosså—åˆ°å‚·å®³: ${damage}, å‰©é¤˜ç”Ÿå‘½: ${this.boss.bossHealth}`);
            
            // é¡¯ç¤ºå‚·å®³æ•¸å­—
            const damageText = this.add.text(this.boss.x, this.boss.y - 30, damage, { 
                fontSize: '24px', 
                fill: '#ff0000',
                fontStyle: 'bold',
                stroke: '#ffffff',
                strokeThickness: 2
            }).setOrigin(0.5);
            
            this.tweens.add({
                targets: damageText,
                y: damageText.y - 40,
                alpha: 0,
                duration: 800,
                onComplete: () => {
                    damageText.destroy();
                }
            });
            
            // Bossè¢«æ“Šä¸­æ•ˆæœ
            this.boss.setTint(0xff0000);
            setTimeout(() => {
                if (this.boss && this.boss.active) {
                    this.boss.clearTint();
                }
            }, 200);
            
            // æª¢æŸ¥Bossæ˜¯å¦æ­»äº¡
            if (this.boss.bossHealth <= 0) {
                // Bossæ­»äº¡äº‹ä»¶
                console.log("Bossè¢«æ“Šæ•—!");
                this.defeatBoss();
            }
            
            // æ›´æ–°Bossè¡€æ¢
            this.updateBossHealthBar();
        });
        
        console.log("Bossäº¤äº’è¨­ç½®å®Œæˆ");
    }
    
    // Bossæ“Šæ•—è™•ç†
    defeatBoss() {
        // æ¨™è¨˜Bosså·²è¢«æ“Šæ•—
        this.bossDefeated = true;
        
        // å¤§é‡ç¶“é©—çå‹µ
        this.gainExperience(500);
        
        // ç§»é™¤Bossè¡€æ¢å’Œåç¨±
        if (this.bossHealthBar) {
            this.bossHealthBar.clear();
        }
        if (this.bossNameText) {
            this.bossNameText.destroy();
            this.bossNameText = null;
        }
        if (this.bossHealthText) {
            this.bossHealthText.destroy();
            this.bossHealthText = null;
        }
        
        // Bossæ­»äº¡æ•ˆæœ
        this.cameras.main.flash(1000, 255, 255, 255);
        this.cameras.main.shake(1000, 0.05);
        
        try {
            // æ’­æ”¾ç²’å­æ•ˆæœ - ä½¿ç”¨try-catché˜²æ­¢ç²’å­æ•ˆæœéŒ¯èª¤
            const particles = this.add.particles('slash');
            const emitter = particles.createEmitter({
                speed: 100,
                scale: { start: 0.05, end: 0.01 },
                alpha: { start: 1, end: 0 },
                lifespan: 1500,
                blendMode: 'ADD'
            });
            
            if (this.boss && this.boss.active) {
                emitter.startFollow(this.boss);
            }
            
            // Bossæ¶ˆå¤±æ•ˆæœ
            this.tweens.add({
                targets: this.boss,
                alpha: 0,
                scale: 1.8,
                duration: 1000,
                onComplete: () => {
                    if (this.boss) {
                        this.boss.destroy();
                        this.boss = null;
                    }
                    
                    // ç¢ºä¿å®‰å…¨åœ°åœæ­¢ç²’å­ç™¼å°„å™¨
                    try {
                        if (emitter) {
                            emitter.stop();
                        }
                    } catch (error) {
                        console.error("åœæ­¢ç²’å­ç™¼å°„å™¨æ™‚ç™¼ç”ŸéŒ¯èª¤:", error);
                    }
                    
                    // å»¶é²ä¸€ä¸‹ï¼Œè®“ç©å®¶çœ‹åˆ°çˆ†ç‚¸æ•ˆæœ
                    setTimeout(() => {
                        try {
                            // é¡¯ç¤ºé€šé—œç•Œé¢
                            this.showVictoryUI();
                        } catch (error) {
                            console.error("é¡¯ç¤ºå‹åˆ©ç•Œé¢æ™‚ç™¼ç”ŸéŒ¯èª¤:", error);
                            // å¦‚æœå‡ºéŒ¯ï¼Œè‡³å°‘é¡¯ç¤ºç°¡å–®çš„å‹åˆ©è¨Šæ¯
                            this.add.text(400, 300, "æ­å–œé€šé—œï¼", {
                                fontSize: '48px',
                                fill: '#ffff00'
                            }).setOrigin(0.5);
                            
                            // æ·»åŠ é‡æ–°é–‹å§‹æŒ‰éˆ•
                            const restartBtn = this.add.text(400, 400, "é‡æ–°é–‹å§‹", {
                                fontSize: '32px',
                                fill: '#ffffff',
                                backgroundColor: '#000000',
                                padding: { x: 20, y: 10 }
                            }).setOrigin(0.5).setInteractive();
                            
                            restartBtn.on('pointerdown', () => location.reload());
                        }
                    }, 1000);
                }
            });
        } catch (error) {
            console.error("Bossæ­»äº¡æ•ˆæœå‡ºéŒ¯:", error);
            // å¦‚æœç‰¹æ•ˆå‡ºéŒ¯ï¼Œç›´æ¥é¡¯ç¤ºå‹åˆ©ç•Œé¢
            setTimeout(() => this.showVictoryUI(), 500);
        }
    }
    
    // é¡¯ç¤ºé€šé—œç•Œé¢
    showVictoryUI() {
        // æ¨™è¨˜éŠæˆ²çµæŸï¼Œé¿å…å…¶ä»–æ›´æ–°é‚è¼¯åŸ·è¡Œ
        this.isGameOver = true;
        
        const gameWidth = this.sys.game.config.width;
        const gameHeight = this.sys.game.config.height;
        
        // èƒŒæ™¯æš—åŒ–
        const overlay = this.add.rectangle(0, 0, gameWidth, gameHeight, 0x000000, 0.7)
            .setOrigin(0)
            .setDepth(100);
        
        // å‹åˆ©æ¨™é¡Œ
        const victoryTitle = this.add.text(gameWidth/2, gameHeight * 0.25, 'æ­å–œé€šé—œ!', {
            fontSize: Math.min(gameWidth, gameHeight) * 0.11 + 'px',
            fill: '#ffff00',
            fontStyle: 'bold',
            stroke: '#000000',
            strokeThickness: 8
        }).setOrigin(0.5).setDepth(101);
        
        // æ·»åŠ å‹åˆ©å…‰ç’°æ•ˆæœ
        const victoryLight = this.add.graphics();
        victoryLight.fillStyle(0xffff00, 0.3);
        victoryLight.fillCircle(gameWidth/2, gameHeight * 0.25, 100);
        victoryLight.setDepth(100);
        
        this.tweens.add({
            targets: victoryLight,
            alpha: 0.1,
            duration: 1500,
            yoyo: true,
            repeat: -1
        });
        
        // è¨ˆç®—éŠæˆ²æ•¸æ“š - ä¿®æ­£éŠæˆ²æ™‚é–“è¨ˆç®—æ–¹å¼
        try {
            // ä½¿ç”¨ç°¡å–®çš„å›ºå®šå€¼ï¼Œé¿å…æ„å¤–éŒ¯èª¤
            let minutes = 0;
            let seconds = 0;
            
            // å¦‚æœéŠæˆ²é–‹å§‹æ™‚é–“å­˜åœ¨ï¼Œå‰‡è¨ˆç®—éŠæˆ²æ™‚é•·
            if (this.gameStartTime) {
                const gameTime = Math.floor((Date.now() - this.gameStartTime) / 1000);
                minutes = Math.floor(gameTime / 60);
                seconds = gameTime % 60;
            }
            
            // ç©å®¶æ•¸æ“š
            const statsText = this.add.text(gameWidth/2, gameHeight * 0.42, 
                `æœ€çµ‚ç­‰ç´š: ${this.playerLevel}\n` +
                `æœ€çµ‚æ”»æ“ŠåŠ›: ${this.playerAttack}\n` +
                `å‰©é¤˜ç”Ÿå‘½å€¼: ${this.playerHealth}\n` +
                `éŠæˆ²æ™‚é–“: ${minutes}åˆ†${seconds}ç§’`, {
                    fontSize: Math.min(gameWidth, gameHeight) * 0.04 + 'px',
                    fill: '#ffffff',
                    align: 'center',
                    stroke: '#000000', 
                    strokeThickness: 3
            }).setOrigin(0.5).setDepth(101);
            
            // æˆå°±è§£é–æç¤º
            let achievementText = '';
            if (this.playerLevel >= 5) {
                achievementText += 'æˆå°±è§£é–: "ç¶“é©—è±å¯Œ"\n';
            }
            if (this.playerHealth >= 80) {
                achievementText += 'æˆå°±è§£é–: "å·§å¦™é–ƒé¿"\n';
            }
            
            if (achievementText) {
                const achievements = this.add.text(gameWidth/2, gameHeight * 0.58, achievementText, {
                    fontSize: Math.min(gameWidth, gameHeight) * 0.033 + 'px',
                    fill: '#00ffff',
                    align: 'center',
                    stroke: '#000000', 
                    strokeThickness: 2
                }).setOrigin(0.5).setDepth(101);
            }
        } catch (error) {
            console.error('é¡¯ç¤ºéŠæˆ²æ•¸æ“šæ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
        }
        
        // é‡æ–°é–‹å§‹æŒ‰éˆ•
        const restartBtn = this.add.text(gameWidth/2, gameHeight * 0.75, 'å†æ¬¡éŠç©', {
            fontSize: Math.min(gameWidth, gameHeight) * 0.053 + 'px',
            fill: '#00ffff',
            backgroundColor: '#333333',
            padding: { x: 20, y: 10 }
        }).setOrigin(0.5).setDepth(101).setInteractive();
        
        restartBtn.on('pointerdown', () => {
            try {
                // é˜²æ­¢å¯èƒ½çš„éŒ¯èª¤å°è‡´éŠæˆ²å¡ä½
                this.registry.destroy();
                this.events.off();
                this.scene.start('LobbyScene');
            } catch (error) {
                console.error('é‡æ–°å•Ÿå‹•éŠæˆ²æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                // å¼·åˆ¶åˆ·æ–°é é¢ä½œç‚ºå¾Œå‚™æ–¹æ¡ˆ
                location.reload();
            }
        });
        
        // æŒ‰éˆ•æ•ˆæœ
        restartBtn.on('pointerover', () => {
            restartBtn.setScale(1.1);
            restartBtn.setFill('#ffffff');
        });
        
        restartBtn.on('pointerout', () => {
            restartBtn.setScale(1);
            restartBtn.setFill('#00ffff');
        });
    }

    // --- æ·»åŠ æˆ¿é–“é€šé“/é–€ ---
    addDoors(x, y) {
        const gameWidth = this.sys.game.config.width;
        const gameHeight = this.sys.game.config.height;
        
        // ä¸Šé–€ (y-1)
        if (y > 0) {
            const topDoor = this.doors.create(gameWidth/2, 30, 'door').setScale(1.7);
            topDoor.setAngle(0);
            topDoor.setOrigin(0.5, 0.5);
            topDoor.setTint(0x00ffff);
            topDoor.setInteractive();
            topDoor.doorDirection = 'up';
            
            // è¨­ç½®è¼ƒå¤§çš„ç¢°æ’å€åŸŸ
            if (topDoor.body) {
                topDoor.body.setSize(100, 60); // åŠ å¤§ç¢°æ’å€åŸŸ
            }
            
            // æ·»åŠ ç¢°æ’æª¢æ¸¬ï¼Œåªé¡¯ç¤ºæç¤ºè€Œä¸ç›´æ¥åˆ‡æ›
            this.physics.add.overlap(this.player, topDoor, () => {
                this.showDoorPrompt(topDoor);
            });
            
            // æ·»åŠ ä¸Šæ–¹é–€çš„æç¤ºæ–‡å­—
            const topText = this.add.text(gameWidth/2, 60, 'â†‘ åŒ—æ–¹', { 
                fontSize: '14px', 
                fill: '#ffffff',
                backgroundColor: '#000000',
                padding: { x: 4, y: 2 }
            }).setOrigin(0.5);
            
            // çŸ­æš«é¡¯ç¤ºå¾Œæ·¡å‡º
            this.tweens.add({
                targets: topText,
                alpha: 0,
                duration: 1000,
                delay: 3000,
                onComplete: () => {
                    topText.destroy();
                }
            });
        }
        
        // ä¸‹é–€ (y+1)
        if (y < this.mapSize - 1) {
            const bottomDoor = this.doors.create(gameWidth/2, gameHeight - 30, 'door').setScale(1.7);
            bottomDoor.setAngle(180);
            bottomDoor.setOrigin(0.5, 0.5);
            bottomDoor.setTint(0x00ffff);
            bottomDoor.setInteractive();
            bottomDoor.doorDirection = 'down';
            
            // è¨­ç½®è¼ƒå¤§çš„ç¢°æ’å€åŸŸ
            if (bottomDoor.body) {
                bottomDoor.body.setSize(100, 60); // åŠ å¤§ç¢°æ’å€åŸŸ
            }
            
            // æ·»åŠ ç¢°æ’æª¢æ¸¬ï¼Œåªé¡¯ç¤ºæç¤ºè€Œä¸ç›´æ¥åˆ‡æ›
            this.physics.add.overlap(this.player, bottomDoor, () => {
                this.showDoorPrompt(bottomDoor);
            });
            
            // æ·»åŠ ä¸‹æ–¹é–€çš„æç¤ºæ–‡å­—
            const bottomText = this.add.text(gameWidth/2, gameHeight - 60, 'â†“ å—æ–¹', { 
                fontSize: '14px', 
                fill: '#ffffff',
                backgroundColor: '#000000',
                padding: { x: 4, y: 2 }
            }).setOrigin(0.5);
            
            // çŸ­æš«é¡¯ç¤ºå¾Œæ·¡å‡º
            this.tweens.add({
                targets: bottomText,
                alpha: 0,
                duration: 1000,
                delay: 3000,
                onComplete: () => {
                    bottomText.destroy();
                }
            });
        }
        
        // å·¦é–€ (x-1)
        if (x > 0) {
            const leftDoor = this.doors.create(30, gameHeight/2, 'door').setScale(1.7);
            leftDoor.setAngle(-90);
            leftDoor.setOrigin(0.5, 0.5);
            leftDoor.setTint(0x00ffff);
            leftDoor.setInteractive();
            leftDoor.doorDirection = 'left';
            
            // è¨­ç½®è¼ƒå¤§çš„ç¢°æ’å€åŸŸ
            if (leftDoor.body) {
                leftDoor.body.setSize(100, 60); // åŠ å¤§ç¢°æ’å€åŸŸ
            }
            
            // æ·»åŠ ç¢°æ’æª¢æ¸¬ï¼Œåªé¡¯ç¤ºæç¤ºè€Œä¸ç›´æ¥åˆ‡æ›
            this.physics.add.overlap(this.player, leftDoor, () => {
                this.showDoorPrompt(leftDoor);
            });
            
            // æ·»åŠ å·¦æ–¹é–€çš„æç¤ºæ–‡å­—
            const leftText = this.add.text(60, gameHeight/2, 'â† è¥¿æ–¹', { 
                fontSize: '14px', 
                fill: '#ffffff',
                backgroundColor: '#000000',
                padding: { x: 4, y: 2 }
            }).setOrigin(0, 0.5);
            
            // çŸ­æš«é¡¯ç¤ºå¾Œæ·¡å‡º
            this.tweens.add({
                targets: leftText,
                alpha: 0,
                duration: 1000,
                delay: 3000,
                onComplete: () => {
                    leftText.destroy();
                }
            });
        }
        
        // å³é–€ (x+1)
        if (x < this.mapSize - 1) {
            const rightDoor = this.doors.create(gameWidth - 30, gameHeight/2, 'door').setScale(1.7);
            rightDoor.setAngle(90);
            rightDoor.setOrigin(0.5, 0.5);
            rightDoor.setTint(0x00ffff);
            rightDoor.setInteractive();
            rightDoor.doorDirection = 'right';
            
            // è¨­ç½®è¼ƒå¤§çš„ç¢°æ’å€åŸŸ
            if (rightDoor.body) {
                rightDoor.body.setSize(100, 60); // åŠ å¤§ç¢°æ’å€åŸŸ
            }
            
            // æ·»åŠ ç¢°æ’æª¢æ¸¬ï¼Œåªé¡¯ç¤ºæç¤ºè€Œä¸ç›´æ¥åˆ‡æ›
            this.physics.add.overlap(this.player, rightDoor, () => {
                this.showDoorPrompt(rightDoor);
            });
            
            // æ·»åŠ å³æ–¹é–€çš„æç¤ºæ–‡å­—
            const rightText = this.add.text(gameWidth - 60, gameHeight/2, 'æ±æ–¹ â†’', { 
                fontSize: '14px', 
                fill: '#ffffff',
                backgroundColor: '#000000',
                padding: { x: 4, y: 2 }
            }).setOrigin(1, 0.5);
            
            // çŸ­æš«é¡¯ç¤ºå¾Œæ·¡å‡º
            this.tweens.add({
                targets: rightText,
                alpha: 0,
                duration: 1000,
                delay: 3000,
                onComplete: () => {
                    rightText.destroy();
                }
            });
        }
    }

    // é¡¯ç¤ºé–€æç¤ºåŠè¨­ç½®ç•¶å‰é–€
    showDoorPrompt(door) {
        // å¦‚æœå·²ç¶“åœ¨åˆ‡æ›æˆ¿é–“ï¼Œå‰‡ä¸é¡¯ç¤ºæç¤º
        if (this.isChangingRoom) return;
        
        // ä¿å­˜ç•¶å‰å¯äº¤äº’çš„é–€
        this.currentDoor = door;
        
        // ç²å–å¯¦éš›ç•«å¸ƒå°ºå¯¸
        const gameWidth = this.sys.game.config.width;
        const gameHeight = this.sys.game.config.height;
        
        // è¨­ç½®æç¤ºæ–‡å­—çš„ä½ç½®
        let promptX = gameWidth/2;
        let promptY = gameHeight * 0.83;
        
        // æ ¹æ“šé–€çš„æ–¹å‘èª¿æ•´æç¤ºä½ç½®
        switch(door.doorDirection) {
            case 'up':
                promptY = door.y + 40;
                break;
            case 'down':
                promptY = door.y - 40;
                break;
            case 'left':
                promptX = door.x + 80;
                promptY = door.y;
                break;
            case 'right':
                promptX = door.x - 80;
                promptY = door.y;
                break;
        }
        
        // é¡¯ç¤ºæç¤ºæ–‡æœ¬
        this.doorPrompt.setVisible(true);
        this.doorPrompt.setPosition(promptX, promptY);
        
        // æ·»åŠ é–ƒçˆæ•ˆæœ
        if (!this.doorPromptTween) {
            this.doorPromptTween = this.tweens.add({
                targets: this.doorPrompt,
                alpha: 0.6,
                duration: 500,
                yoyo: true,
                repeat: -1
            });
        }
    }
    
    // éš±è—é–€æç¤º
    hideDoorPrompt() {
        this.currentDoor = null;
        this.doorPrompt.setVisible(false);
        
        // åœæ­¢é–ƒçˆå‹•ç•«
        if (this.doorPromptTween) {
            this.doorPromptTween.stop();
            this.doorPromptTween = null;
            this.doorPrompt.alpha = 1;
        }
    }
    
    // ç¶“é©—å€¼æ¢æ›´æ–°
    updateExpBar() {
        // ç²å–å¯¦éš›ç•«å¸ƒå°ºå¯¸
        const gameWidth = this.sys.game.config.width;
        const gameHeight = this.sys.game.config.height;
        
        this.expBar.clear();
        this.expBar.fillStyle(0x505050).fillRect(gameWidth * 0.025, gameHeight * 0.15, 200, 10); // èƒŒæ™¯æ¢
        this.expBar.fillStyle(0x00ffff).fillRect(gameWidth * 0.025, gameHeight * 0.15, 200 * (this.playerExp / this.expToNextLevel), 10); // å‰æ™¯æ¢
        this.expText.setText(`ç¶“é©—: ${this.playerExp}/${this.expToNextLevel}`);
    }
    
    // è§’è‰²ç²å¾—ç¶“é©—å€¼
    gainExperience(exp) {
        this.playerExp += exp;
        
        // é¡¯ç¤ºç²å¾—ç¶“é©—å€¼çš„æ–‡å­—
        const expText = this.add.text(this.player.x, this.player.y - 60, `+${exp} ç¶“é©—`, {
            fontSize: '18px',
            fill: '#00ffff'
        }).setOrigin(0.5);
        
        this.tweens.add({
            targets: expText,
            y: expText.y - 30,
            alpha: 0,
            duration: 1500,
            onComplete: () => {
                expText.destroy();
            }
        });
        
        // æª¢æŸ¥æ˜¯å¦å‡ç´š
        if (this.playerExp >= this.expToNextLevel) {
            this.levelUp();
        }
        
        // æ›´æ–°ç¶“é©—å€¼æ¢
        this.updateExpBar();
    }
    
    // è§’è‰²å‡ç´š
    levelUp() {
        // ç²å–å¯¦éš›ç•«å¸ƒå°ºå¯¸
        const gameWidth = this.sys.game.config.width;
        const gameHeight = this.sys.game.config.height;
        
        // æ’­æ”¾å‡ç´šéŸ³æ•ˆ
        try {
            this.levelUpSound.play();
            console.log('æ’­æ”¾å‡ç´šéŸ³æ•ˆ');
        } catch (error) {
            console.warn('æ’­æ”¾å‡ç´šéŸ³æ•ˆå¤±æ•—:', error);
        }
        
        this.playerLevel++;
        this.playerExp -= this.expToNextLevel;
        // å¢åŠ ä¸‹ä¸€ç´šæ‰€éœ€ç¶“é©—
        this.expToNextLevel = Math.floor(this.expToNextLevel * 1.5);
        
        // æé«˜è§’è‰²å±¬æ€§
        this.playerHealth += 20;
        if (this.playerHealth > 100) {
            this.playerHealth = 100; // æ¢å¾©æ»¿è¡€
        }
        this.updateHealthBar();
        
        // æé«˜æ”»æ“ŠåŠ›
        this.playerAttack += 5;
        this.attackText.setText(`æ”»æ“ŠåŠ›: ${this.playerAttack}`); // æ›´æ–°æ”»æ“ŠåŠ›é¡¯ç¤º
        
        // é¡¯ç¤ºå‡ç´šæ•ˆæœ
        this.cameras.main.flash(500, 255, 255, 0); // é»ƒè‰²é–ƒå…‰
        
        // å‡ç´šæ–‡å­—
        const levelUpText = this.add.text(gameWidth/2, gameHeight/2, 'å‡ç´šï¼', {
            fontSize: '48px',
            fill: '#ffff00',
            fontStyle: 'bold',
            stroke: '#000000',
            strokeThickness: 6
        }).setOrigin(0.5).setDepth(100);
        
        // é¡¯ç¤ºå‡ç´šç²å¾—çš„æå‡
        const bonusText = this.add.text(gameWidth/2, gameHeight * 0.58, `ç”Ÿå‘½å€¼ä¸Šé™ +20\næ”»æ“ŠåŠ› +5 (ç›®å‰: ${this.playerAttack})`, {
            fontSize: '22px',
            fill: '#ffffff',
            stroke: '#000000',
            strokeThickness: 4,
            align: 'center'
        }).setOrigin(0.5).setDepth(100);
        
        // å‹•ç•«æ•ˆæœ
        this.tweens.add({
            targets: [levelUpText, bonusText],
            alpha: 0,
            y: '-=50',
            duration: 2000,
            onComplete: () => {
                levelUpText.destroy();
                bonusText.destroy();
            }
        });
        
        // æ›´æ–°ç­‰ç´šé¡¯ç¤º
        this.levelText.setText(`ç­‰ç´š: ${this.playerLevel}`);
        this.updateExpBar();
    }

    // --- å°åœ°åœ–ç¹ªè£½ ---
    drawMiniMap() {
        // è¨­å®šå°åœ°åœ–å¤§å°å’Œä½ç½®
        const size = 20, gap = 4;
        const offsetX = 1285 - (this.mapSize * (size + gap)) / 2;
        const offsetY = 130 - (this.mapSize * (size + gap)) / 2;
        
        // æ¸…é™¤èˆŠçš„å°åœ°åœ–åœ–å½¢
        this.miniMap.clear();
        
        // ç¹ªè£½æˆ¿é–“æ–¹æ ¼
        for (let y = 0; y < this.mapSize; y++) {
            for (let x = 0; x < this.mapSize; x++) {
                // æ±ºå®šé¡è‰²å’Œé€æ˜åº¦
                let color, borderColor, alpha = 1;
                
                // æœªæ¢ç´¢æˆ¿é–“
                if (!this.roomMap[y][x].visited) {
                    color = 0x333333;
                    borderColor = 0x666666;
                    alpha = 0.6;
                } 
                // å·²æ¢ç´¢æˆ¿é–“
                else {
                    color = 0xaaaaaa;
                    borderColor = 0xffffff;
                    
                    // ç•¶å‰æˆ¿é–“ç‰¹æ®Šé¡¯ç¤º
                    if (x === this.roomX && y === this.roomY) {
                        color = 0x00ff00;  // äº®ç¶ è‰²
                        borderColor = 0xffff00;  // é»ƒè‰²é‚Šæ¡†
                        alpha = 1;
                    }
                }
                
                // ç¹ªè£½æˆ¿é–“å¡«å……
                this.miniMap.fillStyle(color, alpha);
                this.miniMap.fillRect(
                    offsetX + x * (size + gap),
                    offsetY + y * (size + gap),
                    size, size
                );
                
                // ç¹ªè£½æˆ¿é–“é‚Šæ¡†
                this.miniMap.lineStyle(1, borderColor, alpha);
                this.miniMap.strokeRect(
                    offsetX + x * (size + gap),
                    offsetY + y * (size + gap),
                    size, size
                );
                
                // å¦‚æœæ˜¯ç•¶å‰æˆ¿é–“ï¼Œæ·»åŠ é–ƒçˆæ•ˆæœ
                if (x === this.roomX && y === this.roomY) {
                    if (!this.currentRoomMarker) {
                        this.currentRoomMarker = this.add.rectangle(
                            offsetX + x * (size + gap) + size/2,
                            offsetY + y * (size + gap) + size/2,
                            size, size,
                            0xffffff, 0.5
                        ).setDepth(10);
                        
                        // æ·»åŠ é–ƒçˆå‹•ç•«
                        this.tweens.add({
                            targets: this.currentRoomMarker,
                            alpha: 0.2,
                            duration: 800,
                            yoyo: true,
                            repeat: -1
                        });
                    } else {
                        // æ›´æ–°ä½ç½®
                        this.currentRoomMarker.setPosition(
                            offsetX + x * (size + gap) + size/2,
                            offsetY + y * (size + gap) + size/2
                        );
                    }
                }
                
                // é¡¯ç¤ºç›¸é„°æˆ¿é–“çš„é–€/é€šé“
                const drawPath = (adjacentX, adjacentY, color) => {
                    if (adjacentX >= 0 && adjacentX < this.mapSize &&
                        adjacentY >= 0 && adjacentY < this.mapSize &&
                        this.roomMap[adjacentY][adjacentX].visited) {
                        
                        // è¨ˆç®—ä¸­å¿ƒé»
                        const centerX1 = offsetX + x * (size + gap) + size/2;
                        const centerY1 = offsetY + y * (size + gap) + size/2;
                        const centerX2 = offsetX + adjacentX * (size + gap) + size/2;
                        const centerY2 = offsetY + adjacentY * (size + gap) + size/2;
                        
                        // ç¹ªè£½é€£æ¥ç·š
                        this.miniMap.lineStyle(3, color, 0.8);
                        this.miniMap.beginPath();
                        this.miniMap.moveTo(centerX1, centerY1);
                        this.miniMap.lineTo((centerX1 + centerX2)/2, (centerY1 + centerY2)/2);
                        this.miniMap.closePath();
                        this.miniMap.strokePath();
                    }
                };
                
                // ç¹ªè£½é€šé“é€£æ¥
                if (this.roomMap[y][x].visited) {
                    // ä¸Šæ–¹
                    if (y > 0) drawPath(x, y-1, 0x00ffff);
                    // ä¸‹æ–¹
                    if (y < this.mapSize-1) drawPath(x, y+1, 0x00ffff);
                    // å·¦æ–¹
                    if (x > 0) drawPath(x-1, y, 0x00ffff);
                    // å³æ–¹
                    if (x < this.mapSize-1) drawPath(x+1, y, 0x00ffff);
                }
            }
        }
        
        // ç¢ºä¿å°åœ°åœ–å§‹çµ‚åœ¨æœ€ä¸Šå±¤
        this.miniMap.setDepth(10);
    }
    
    // --- è¡€é‡æ¢æ›´æ–° ---
    updateHealthBar() {
        // ç²å–å¯¦éš›ç•«å¸ƒå°ºå¯¸
        const gameWidth = this.sys.game.config.width;
        const gameHeight = this.sys.game.config.height;
        
        this.healthBar.clear();
        this.healthBar.fillStyle(0x808080).fillRect(gameWidth * 0.025, gameHeight * 0.033, 200, 20);
        this.healthBar.fillStyle(0xff0000).fillRect(gameWidth * 0.025, gameHeight * 0.033, 2 * this.playerHealth, 20);
        this.healthText.setText(`HP: ${this.playerHealth}`);
    }
    updateSlimeHealthBar() {
        this.slimeHealthBar.clear();
        
        // æª¢æŸ¥ slimes æ˜¯å¦å­˜åœ¨
        if (!this.slimes) return;
        
        // ä½¿ç”¨ getChildren ç²å–çµ„ä¸­çš„å­å…ƒç´ 
        const slimeChildren = this.slimes.getChildren();
        
        // æª¢æŸ¥æ˜¯å¦æœ‰æ€ªç‰©
        if (!slimeChildren || slimeChildren.length === 0) return;
        
        const barWidth = 40, barHeight = 6, offsetY = 20;
        
        slimeChildren.forEach(slime => {
            // åªç‚ºæ´»è‘—ä¸”æœªæ¨™è¨˜ç‚ºæ­»äº¡çš„æ€ªç‰©ã€é€æ˜åº¦ç‚º1çš„æ€ªç‰©é¡¯ç¤ºè¡€æ¢
            if (slime && 
                slime.active && 
                !slime.isDead && 
                slime.alpha === 1 &&  // ç¢ºä¿åªç‚ºå®Œå…¨ä¸é€æ˜çš„æ€ªç‰©é¡¯ç¤ºè¡€æ¢
                typeof slime.slimeHealth !== 'undefined' && 
                typeof slime.maxHealth !== 'undefined') {
                
                // æ ¹æ“šç”Ÿå‘½å€¼æ¯”ä¾‹æ±ºå®šé¡è‰²
                let healthColor = 0x00ff00; // é»˜èªç¶ è‰²
                
                const healthRatio = slime.slimeHealth / slime.maxHealth;
                if (healthRatio < 0.3) {
                    healthColor = 0xff0000; // å°‘æ–¼30%è¡€é‡é¡¯ç¤ºç´…è‰²
                } else if (healthRatio < 0.6) {
                    healthColor = 0xffff00; // å°‘æ–¼60%è¡€é‡é¡¯ç¤ºé»ƒè‰²
                }
                
                // ç¹ªè£½è¡€æ¢èƒŒæ™¯
                this.slimeHealthBar.fillStyle(0x000000, 0.7).fillRect(
                    slime.x - barWidth / 2 - 1, 
                    slime.y - offsetY - 1, 
                    barWidth + 2, 
                    barHeight + 2
                );
                
                // ç¹ªè£½è¡€æ¢å‰æ™¯
                this.slimeHealthBar.fillStyle(healthColor).fillRect(
                    slime.x - barWidth / 2, 
                    slime.y - offsetY, 
                    (barWidth * slime.slimeHealth) / slime.maxHealth, 
                    barHeight
                );
            }
        });
    }
    
    // --- é¡¯ç¤ºå¤±æ•—èˆ‡é‡æ–°é–‹å§‹æŒ‰éˆ• ---
    showGameOverUI() {
        // ç²å–å¯¦éš›ç•«å¸ƒå°ºå¯¸
        const gameWidth = this.sys.game.config.width;
        const gameHeight = this.sys.game.config.height;
        
        // å¤±æ•—å¤§å­—
        this.failText = this.add.text(gameWidth/2, gameHeight * 0.37, 'å¤±æ•—', { 
            fontSize: Math.min(gameWidth, gameHeight) * 0.11 + 'px', 
            fill: '#ff0000', 
            fontStyle: 'bold' 
        }).setOrigin(0.5);
        // é‡æ–°é–‹å§‹æŒ‰éˆ•
        this.restartBtn = this.add.text(gameWidth/2, gameHeight * 0.53, 'é‡æ–°é–‹å§‹', { 
            fontSize: Math.min(gameWidth, gameHeight) * 0.06 + 'px', 
            fill: '#fff', 
            backgroundColor: '#222', 
            padding: { x: 30, y: 10 } 
        })
            .setOrigin(0.5)
            .setInteractive({ useHandCursor: true });
        this.restartBtn.on('pointerdown', () => {
            this.scene.restart(); // é‡æ–°å•Ÿå‹•æœ¬å ´æ™¯
        });
    }
    
    // æ·»åŠ é–€ç¢°æ’è™•ç†æ–¹æ³•
    handleDoorCollision(direction) {
        // ç²å–å¯¦éš›ç•«å¸ƒå°ºå¯¸
        const gameWidth = this.sys.game.config.width;
        const gameHeight = this.sys.game.config.height;
        
        // é˜²æ­¢é‡è¤‡å¿«é€Ÿåˆ‡æ›
        if (this.isChangingRoom) {
            console.log('æ­£åœ¨åˆ‡æ›æˆ¿é–“ï¼Œè«‹ç¨å€™...');
        return;
    }

        // æ¨™è¨˜æ­£åœ¨åˆ‡æ›æˆ¿é–“
        this.isChangingRoom = true;
        console.log(`å‰å¾€${direction}æ–¹å‘çš„æˆ¿é–“`);
        
        // éš±è—é–€æç¤º
        this.hideDoorPrompt();
        
        // æ ¹æ“šæ–¹å‘ç¢ºå®šç›®æ¨™æˆ¿é–“åæ¨™
        let nx = this.roomX, ny = this.roomY;
        if (direction === 'left') {
            nx--;
            this.player.anims.play('left');
        }
        if (direction === 'right') {
            nx++;
            this.player.anims.play('right');
        }
        if (direction === 'up') {
            ny--;
            this.player.anims.play('up');
        }
        if (direction === 'down') {
            ny++;
            this.player.anims.play('down');
        }
        
        // ç¢ºä¿ç›®æ¨™æˆ¿é–“åœ¨æœ‰æ•ˆç¯„åœå…§
        if (nx >= 0 && nx < this.mapSize && ny >= 0 && ny < this.mapSize) {
            // é¡¯ç¤ºåˆ‡æ›ç‰¹æ•ˆ
            this.cameras.main.fadeOut(300, 0, 0, 0);
            
            // ç­‰å¾…æ·¡å‡ºå®Œæˆå¾Œå†ç”Ÿæˆæ–°æˆ¿é–“
            this.cameras.main.once('camerafadeoutcomplete', () => {
                // æ›´æ–°æˆ¿é–“åæ¨™
                this.roomX = nx;
                this.roomY = ny;
                
                // ç”Ÿæˆæ–°æˆ¿é–“
                this.generateRoom(this.roomX, this.roomY);
                
                // è¨­å®šç©å®¶ä½ç½®åˆ°æ–°æˆ¿é–“æ­£ç¢ºçš„å…¥å£ä½ç½®
                const gameWidth = this.sys.game.config.width;
                const gameHeight = this.sys.game.config.height;
                
                switch(direction) {
                    case 'left':
                        this.player.setPosition(gameWidth - 100, gameHeight/2); // å³å´å…¥å£
                        break;
                    case 'right':
                        this.player.setPosition(100, gameHeight/2);  // å·¦å´å…¥å£
                        break; 
                    case 'up':
                        this.player.setPosition(gameWidth/2, gameHeight - 100); // ä¸‹æ–¹å…¥å£
                        break;
                    case 'down':
                        this.player.setPosition(gameWidth/2, 100);  // ä¸Šæ–¹å…¥å£
                        break;
                }
                
                // æ·¡å…¥æ•ˆæœ
                this.cameras.main.fadeIn(300);
                
                // é¡¯ç¤ºæ–¹å‘æç¤º
                let dirText = '';
                if (direction === 'left') dirText = 'å‘è¥¿';
                if (direction === 'right') dirText = 'å‘æ±';
                if (direction === 'up') dirText = 'å‘åŒ—';
                if (direction === 'down') dirText = 'å‘å—';
                
                const roomText = this.add.text(gameWidth/2, gameHeight * 0.17, `${dirText}ç§»å‹•åˆ°æ–°æˆ¿é–“ (${this.roomX},${this.roomY})`, { 
                    fontSize: '20px', 
                    fill: '#ffffff',
                    backgroundColor: '#000000',
                    padding: { x: 10, y: 5 }
                }).setOrigin(0.5);
                
                // 2ç§’å¾Œæ·¡å‡ºæç¤º
                this.tweens.add({
                    targets: roomText,
                    alpha: 0,
                    duration: 1000,
                    delay: 1000,
                    onComplete: () => {
                        roomText.destroy();
                    }
                });
                
                // çŸ­æš«å»¶é²å¾Œå…è¨±å†æ¬¡åˆ‡æ›æˆ¿é–“
                setTimeout(() => {
                    this.isChangingRoom = false;
                    console.log('å¯ä»¥å†æ¬¡åˆ‡æ›æˆ¿é–“');
                }, 1000);
            });
    } else {
            // å¦‚æœç›®æ¨™æˆ¿é–“ä¸åœ¨æœ‰æ•ˆç¯„åœå…§ï¼Œé‡ç½®ç‹€æ…‹
            this.isChangingRoom = false;
        }
    }

    update() {
        if (this.isGameOver) {
            this.player.setVelocity(0);
            return;
        }
        
        // é‡ç½®ç©å®¶é€Ÿåº¦
        this.player.setVelocity(0);
        
        // æª¢æ¸¬ E éµæ˜¯å¦æŒ‰ä¸‹ï¼Œå¦‚æœæœ‰ç•¶å‰å¯äº¤äº’çš„é–€ï¼Œå‰‡é€²è¡Œæˆ¿é–“åˆ‡æ›
        if (Phaser.Input.Keyboard.JustDown(this.eKey) && this.currentDoor) {
            this.handleDoorCollision(this.currentDoor.doorDirection);
            this.hideDoorPrompt();
        }
        
        // æª¢æ¸¬ R éµæ˜¯å¦æŒ‰ä¸‹ï¼Œå¦‚æœæœ‰èƒ½é‡é£²æ–™ï¼Œå‰‡ä½¿ç”¨
        if (Phaser.Input.Keyboard.JustDown(this.rKey)) {
            this.useEnergyDrink();
        }
        
        // å¦‚æœç©å®¶æ²’æœ‰èˆ‡ä»»ä½•é–€é‡ç–Šï¼Œéš±è—æç¤º
        if (!this.physics.overlap(this.player, this.doors)) {
            this.hideDoorPrompt();
        }
        
        // --- ç§»å‹•èˆ‡é¢å‘åˆ¤æ–· ---
        if (this.cursors.left.isDown) {
            this.player.setVelocityX(-100);
            this.player.anims.play('left', true);
            this.facing = 'left'; // è¨˜éŒ„é¢å‘
        } else if (this.cursors.right.isDown) {
            this.player.setVelocityX(100);
            this.player.anims.play('right', true);
            this.facing = 'right';
        } else if (this.cursors.up.isDown) {
            this.player.setVelocityY(-100);
            this.player.anims.play('up', true);
            this.facing = 'up';
        } else if (this.cursors.down.isDown) {
            this.player.setVelocityY(100);
            this.player.anims.play('down', true);
            this.facing = 'down';
        } else {
            this.player.anims.stop();
        }
        
        // --- ç™¼å°„åŠæ°£ï¼Œæ–¹å‘ä¾ç…§é¢å‘ ---
        if (Phaser.Input.Keyboard.JustDown(this.spaceKey)) {
            // æ’­æ”¾æ®åŠéŸ³æ•ˆ
            try {
                this.slashSound.play();
            } catch (error) {
                console.warn('æ’­æ”¾æ®åŠéŸ³æ•ˆå¤±æ•—:', error);
            }
            
            let slash = this.slashes.create(this.player.x, this.player.y, 'slash');
    slash.setScale(0.05);
    slash.body.setAllowGravity(false);
            // ä¾ç…§é¢å‘æ–¹å‘ç™¼å°„
            if (this.facing === 'left') {
        slash.setVelocityX(-300);
                slash.setAngle(0);
            } else if (this.facing === 'right') {
        slash.setVelocityX(300);
                slash.setAngle(180);
            } else if (this.facing === 'up') {
        slash.setVelocityY(-300);
                slash.setAngle(90);
    } else {
        slash.setVelocityY(300);
                slash.setAngle(270);
            }
            
            // æ·»åŠ åŠæ°£å…‰æ•ˆ
            this.tweens.add({
                targets: slash,
                alpha: 0.8,
                duration: 100,
                yoyo: true,
                repeat: 1
            });
            
            // è‡ªå‹•éŠ·æ¯€ï¼Œé¿å…éŠæˆ²å°è±¡å †ç©
            setTimeout(() => {
                if (slash && slash.active) {
                    slash.destroy();
                }
            }, 2000);
        }
        
        // æŠ€èƒ½ä¸€ï¼šQéµæ–½æ”¾ç¯„åœçˆ†ç‚¸
        if (Phaser.Input.Keyboard.JustDown(this.qKey)) {
            // æ’­æ”¾æŠ€èƒ½ä¸€éŸ³æ•ˆ
            try {
                this.skill1Sound.play();
            } catch (error) {
                console.warn('æ’­æ”¾æŠ€èƒ½ä¸€éŸ³æ•ˆå¤±æ•—:', error);
            }
            this.useSkill1();
        }
        
        // æŠ€èƒ½äºŒï¼šWéµæ–½æ”¾ä¸‰é‡èƒ½é‡å½ˆ
        if (Phaser.Input.Keyboard.JustDown(this.wKey)) {
            // æ’­æ”¾æŠ€èƒ½äºŒéŸ³æ•ˆ
            try {
                this.skill2Sound.play();
            } catch (error) {
                console.warn('æ’­æ”¾æŠ€èƒ½äºŒéŸ³æ•ˆå¤±æ•—:', error);
            }
            this.useSkill2();
        }
        
        // å²èŠå§†è¿½è¹¤ç©å®¶ï¼Œå…ˆæª¢æŸ¥æ˜¯å¦å­˜åœ¨ä¸”æ˜¯æ´»çš„
        if (this.slimes) {
            // ä½¿ç”¨ getChildren ç²å–çµ„ä¸­çš„å­å…ƒç´ 
            const slimeChildren = this.slimes.getChildren();
            
            // æª¢æŸ¥æ˜¯å¦æœ‰æ€ªç‰©
            if (slimeChildren && slimeChildren.length > 0) {
                slimeChildren.forEach(slime => {
                    if (slime && slime.active && !slime.isDead) {
                        // ç¢ºä¿æ­¤å²èŠå§†æ²’æœ‰è¢«æ¨™è¨˜ç‚ºæ­»äº¡
                        this.physics.moveToObject(slime, this.player, slime.slimeSpeed || 40);
                    }
                });
            }
            
            // æ›´æ–°æ€ªç‰©è¡€æ¢
            this.updateSlimeHealthBar();
        }
        
        // æ›´æ–°Bossçš„è¡Œç‚º(å¦‚æœå­˜åœ¨)
        if (this.boss && !this.bossDefeated) {
            // è®“Bossæ…¢æ…¢ç§»å‘ç©å®¶
            this.physics.moveToObject(this.boss, this.player, this.boss.moveSpeed);
            
            // æ›´æ–°Bossè¡€æ¢
            this.updateBossHealthBar();
        }
        
        // ç¢ºä¿å°åœ°åœ–ä¿æŒæ›´æ–°
        if (this.time.now % 60 === 0) { // æ¯60æ¯«ç§’æ›´æ–°ä¸€æ¬¡ï¼Œé¿å…éæ–¼é »ç¹
            this.drawMiniMap();
        }
        
        // æ›´æ–°æŠ€èƒ½UIç‹€æ…‹
        this.updateSkillUI();
    }

    // Bossè¡€æ¢æ›´æ–°
    updateBossHealthBar() {
        if (!this.boss || !this.bossHealthBar) return;
        
        // ç²å–å¯¦éš›ç•«å¸ƒå°ºå¯¸
        const gameWidth = this.sys.game.config.width;
        const gameHeight = this.sys.game.config.height;
        
        this.bossHealthBar.clear();
        
        // Bossè¡€æ¢èƒŒæ™¯
        this.bossHealthBar.fillStyle(0x222222, 0.8);
        this.bossHealthBar.fillRect(gameWidth * 0.1875, gameHeight * 0.05, gameWidth * 0.625, 25);
        
        // Bossè¡€æ¢
        const healthPercent = this.boss.bossHealth / this.boss.maxHealth;
        let barColor;
        
        // æ ¹æ“šè¡€é‡ç™¾åˆ†æ¯”é¡¯ç¤ºä¸åŒé¡è‰²
        if (healthPercent > 0.6) {
            barColor = 0x00ff00; // ç¶ è‰²
        } else if (healthPercent > 0.3) {
            barColor = 0xffff00; // é»ƒè‰²
        } else {
            barColor = 0xff0000; // ç´…è‰²
        }
        
        this.bossHealthBar.fillStyle(barColor, 1);
        this.bossHealthBar.fillRect(gameWidth * 0.1875, gameHeight * 0.05, (gameWidth * 0.625) * healthPercent, 25);
        
        // é¡¯ç¤ºBossåç¨±å’Œè¡€é‡
        if (!this.bossNameText) {
            this.bossNameText = this.add.text(gameWidth/2, gameHeight * 0.025, 'æš—å½±é­”ç‹', {
                fontSize: '18px',
                fill: '#ffffff',
                stroke: '#000000',
                strokeThickness: 3
            }).setOrigin(0.5);
        }
        
        if (!this.bossHealthText) {
            this.bossHealthText = this.add.text(gameWidth/2, gameHeight * 0.07, `${this.boss.bossHealth}/${this.boss.maxHealth}`, {
                fontSize: '16px',
                fill: '#ffffff'
            }).setOrigin(0.5);
        } else {
            this.bossHealthText.setText(`${this.boss.bossHealth}/${this.boss.maxHealth}`);
        }
    }
    
    // æ™®é€šæˆ¿é–“ç”Ÿæˆ(åŸæœ‰çš„ç”Ÿæˆé‚è¼¯)
    generateNormalRoom() {
        // ç²å–å¯¦éš›ç•«å¸ƒå°ºå¯¸
        const gameWidth = this.sys.game.config.width;
        const gameHeight = this.sys.game.config.height;
        
        // éš¨æ©Ÿç”Ÿæˆå¯¶ç®±
        if (this.random.frac() < 0.5) {
            const chestX = this.random.between(100, gameWidth - 100);
            const chestY = this.random.between(100, gameHeight - 100);
            this.chest = this.physics.add.image(chestX, chestY, 'chest').setScale(1.7);
            this.chest.body.setAllowGravity(false);
            this.physics.add.overlap(this.player, this.chest, () => {
                this.chest.destroy();
                this.energyIcon.setVisible(true);
                this.energyPrompt.setVisible(true);
                
                // æ·»åŠ ç²å¾—å¯¶ç®±çš„æç¤º
                const treasureText = this.add.text(gameWidth/2, gameHeight * 0.25, 'ç²å¾—å¯¶ç®±ï¼èƒ½é‡é£²æ–™å·²æ·»åŠ åˆ°ç‰©å“æ¬„', { 
                    fontSize: '18px', 
                    fill: '#ffff00'
                }).setOrigin(0.5);
                
                // 2ç§’å¾Œæ·¡å‡º
                this.tweens.add({
                    targets: treasureText,
                    alpha: 0,
                    duration: 1000,
                    delay: 1000,
                    onComplete: () => {
                        treasureText.destroy();
                    }
                });
            });
        } else {
            this.chest = null;
        }
        
        // ç”Ÿæˆ2-3éš»æ€ªç‰©
        const monsterCount = this.random.between(2, 3);
        
        // æ ¹æ“šæˆ¿é–“åº§æ¨™è¨ˆç®—åŸºç¤é›£åº¦
        const farFromStart = Math.abs(this.roomX - 2) + Math.abs(this.roomY - 2);
        const baseDifficulty = 1 + (farFromStart * 0.2);
        
        for (let i = 0; i < monsterCount; i++) {
            // ç‚ºæ¯éš»æ€ªç‰©ç”Ÿæˆéš¨æ©Ÿä½ç½®
            let slimeX, slimeY, isValidPosition;
            
            // ç¢ºä¿æ€ªç‰©ä¹‹é–“æœ‰è¶³å¤ è·é›¢
            do {
                isValidPosition = true;
                slimeX = this.random.between(100, gameWidth - 100);
                slimeY = this.random.between(100, gameHeight - 100);
                
                // æª¢æŸ¥èˆ‡å¯¶ç®±çš„è·é›¢
                if (this.chest && 
                    Phaser.Math.Distance.Between(slimeX, slimeY, this.chest.x, this.chest.y) < 100) {
                    isValidPosition = false;
                    continue;
                }
                
                // æª¢æŸ¥èˆ‡å…¶ä»–æ€ªç‰©çš„è·é›¢
                this.slimes.getChildren().forEach(existingSlime => {
                    if (Phaser.Math.Distance.Between(slimeX, slimeY, existingSlime.x, existingSlime.y) < 150) {
                        isValidPosition = false;
                    }
                });
                
                // æª¢æŸ¥èˆ‡ç©å®¶çš„è·é›¢ï¼ˆé¿å…æ€ªç‰©ç”Ÿæˆåœ¨ç©å®¶é™„è¿‘ï¼‰
                if (Phaser.Math.Distance.Between(slimeX, slimeY, this.player.x, this.player.y) < 150) {
                    isValidPosition = false;
                }
                
            } while (!isValidPosition);
            
            // ç‚ºæ¯éš»æ€ªç‰©è¨­ç½®ä¸åŒç‰¹æ€§
            const typeVariant = this.random.between(0, 2); // 0:æ™®é€šï¼Œ1:å¼·å£¯ï¼Œ2:å¿«é€Ÿ
            
            // è¨ˆç®—æ€ªç‰©å±¬æ€§
            let slimeHealth, slimeScale, slimeSpeed, slimeColor, slimeType;
            switch(typeVariant) {
                case 0: // æ™®é€šæ€ªç‰©
                    slimeHealth = Math.floor(80 * baseDifficulty);
                    slimeScale = 1.2 + (baseDifficulty * 0.1);
                    slimeSpeed = 40;
                    slimeColor = 0xffffff; // ç™½è‰²
                    slimeType = 'æ™®é€š';
                    break;
                case 1: // å¼·å£¯æ€ªç‰©
                    slimeHealth = Math.floor(150 * baseDifficulty);
                    slimeScale = 1.8 + (baseDifficulty * 0.15);
                    slimeSpeed = 30;
                    slimeColor = 0xff5500; // æ©™è‰²
                    slimeType = 'å¼·å£¯';
                    break;
                case 2: // å¿«é€Ÿæ€ªç‰©
                    slimeHealth = Math.floor(60 * baseDifficulty);
                    slimeScale = 1.0 + (baseDifficulty * 0.05);
                    slimeSpeed = 70;
                    slimeColor = 0x00ffff; // é’è‰²
                    slimeType = 'å¿«é€Ÿ';
                    break;
            }
            
            // å‰µå»ºæ€ªç‰©
            const slime = this.physics.add.sprite(slimeX, slimeY, 'slime')
                .setCollideWorldBounds(true)
                .setScale(slimeScale)
                .setTint(slimeColor)
                .play('slime_move');
            
            // è¨­ç½®æ€ªç‰©å±¬æ€§
            slime.slimeType = slimeType;
            slime.slimeHealth = slimeHealth;
            slime.maxHealth = slimeHealth;
            slime.slimeSpeed = slimeSpeed;
            
            // æ·»åŠ åˆ°æ€ªç‰©çµ„
            this.slimes.add(slime);
            
            // æ·»åŠ ç¢°æ’
            this.physics.add.collider(slime, this.walls);
            
            // æ·»åŠ èˆ‡ç©å®¶çš„äº¤äº’
            this.physics.add.overlap(this.player, slime, () => {
                if (this.isGameOver) return;
                
                const now = this.time.now;
                if (!slime.lastAttackTime || now - slime.lastAttackTime >= 1000) {
                    // æ ¹æ“šæ€ªç‰©é¡å‹é€ æˆä¸åŒå‚·å®³
                    let damage = 5;
                    if (slime.slimeType === 'å¼·å£¯') damage = 10;
                    if (slime.slimeType === 'å¿«é€Ÿ') damage = 3;
                    
                    this.playerHealth -= damage;
                    if (this.playerHealth < 0) this.playerHealth = 0;
                    this.updateHealthBar();
                    slime.lastAttackTime = now;
                    
                    // é¡¯ç¤ºå—å‚·æ•ˆæœ
                    this.cameras.main.flash(200, 255, 0, 0, true);
                    
                    // é¡¯ç¤ºå‚·å®³æ–‡å­—
                    const damageText = this.add.text(this.player.x, this.player.y - 40, `-${damage}`, { 
                        fontSize: '20px', 
                        fill: '#ff0000',
                        fontStyle: 'bold'
                    }).setOrigin(0.5);
                    
                    this.tweens.add({
                        targets: damageText,
                        y: damageText.y - 30,
                        alpha: 0,
                        duration: 800,
                        onComplete: () => {
                            damageText.destroy();
                        }
                    });
                    
                    if (this.playerHealth === 0) {
                        this.isGameOver = true;
                        this.player.setTint(0xff0000);
                        this.player.anims.stop();
                        this.showGameOverUI();
                    }
                }
            });
            
            // æ·»åŠ èˆ‡åŠæ°£çš„äº¤äº’
            this.physics.add.overlap(this.slashes, slime, (slime, slash) => {
                slash.destroy();
                
                // ç¢ºä¿ slime ç‰©ä»¶å­˜åœ¨ä¸”æœ‰ slimeHealth å±¬æ€§
                if (!slime || !slime.active || typeof slime.slimeHealth === 'undefined') {
                    return;
                }
                
                // é€ æˆå‚·å®³ - ä½¿ç”¨ç©å®¶æ”»æ“ŠåŠ›
                let damage = this.playerAttack;
                slime.slimeHealth -= damage;
                
                // é¡¯ç¤ºå‚·å®³æ•¸å­—
                const damageText = this.add.text(slime.x, slime.y - 30, damage, { 
                    fontSize: '18px', 
                    fill: '#ff0000',
                    fontStyle: 'bold'
                }).setOrigin(0.5);
                
                this.tweens.add({
                    targets: damageText,
                    y: damageText.y - 50,
                    alpha: 0,
                    duration: 800,
                    onComplete: () => {
                        damageText.destroy();
                    }
                });
                
                // æª¢æŸ¥æ€ªç‰©æ˜¯å¦æ­»äº¡
                if (slime.slimeHealth <= 0) {
                    // æ¨™è¨˜ç‚ºå·²æ­»äº¡ï¼Œé¿å…é‡è¤‡è™•ç†
                    slime.isDead = true;
                    
                    // ç«‹å³ç§»é™¤è¡€æ¢ï¼ˆé€šéè¨­ç½®é€æ˜åº¦ç‚º0ï¼‰
                    slime.alpha = 0.9;
                    
                    // å…ˆæ¸…é™¤è¡€æ¢
                    this.updateSlimeHealthBar();
                    
                    // æ ¹æ“šæ€ªç‰©é¡å‹ç²å¾—ä¸åŒç¶“é©—å€¼
                    let expGained = 80; // é»˜èªç¶“é©—
                    if (slime.slimeType === 'å¼·å£¯') {
                        expGained = 180; // å¼·å£¯æ€ªç‰©çµ¦äºˆæ›´å¤šç¶“é©—
                    } else if (slime.slimeType === 'å¿«é€Ÿ') {
                        expGained = 120; // å¿«é€Ÿæ€ªç‰©çµ¦äºˆä¸­ç­‰ç¶“é©—
                    }
                    
                    // ç²å¾—ç¶“é©—å€¼
                    this.gainExperience(expGained);
                    
                    // æ€ªç‰©æ­»äº¡æ•ˆæœ
                    this.tweens.add({
                        targets: slime,
                        alpha: 0,
                        scale: slime.scale * 0.5,
                        duration: 300,
                        onComplete: () => {
                            // ç¢ºä¿æ­»äº¡æ™‚å¾¹åº•å¾ç³»çµ±ä¸­ç§»é™¤
                            slime.destroy();
                            
                            // éš¨æ©Ÿæ‰è½èƒ½é‡é£²æ–™ (15% å¹¾ç‡)
                            if (this.random.frac() < 0.15) {
                                this.energyIcon.setVisible(true);
                                this.energyPrompt.setVisible(true);
                                
                                // é¡¯ç¤ºæ‰è½æç¤º
                                const dropText = this.add.text(slime.x, slime.y, 'æ‰è½èƒ½é‡é£²æ–™ï¼', { 
                                    fontSize: '16px', 
                                    fill: '#00ffff'
                                }).setOrigin(0.5);
                                
                                this.tweens.add({
                                    targets: dropText,
                                    y: dropText.y - 30,
                                    alpha: 0,
                                    duration: 1500,
                                    onComplete: () => {
                                        dropText.destroy();
                                    }
                                });
                            }
                        }
                    });
                    
                    // é¡¯ç¤ºæ“Šæ•—æ–‡å­—
                    const victoryText = this.add.text(slime.x, slime.y - 50, `æ“Šæ•—${slime.slimeType}æ€ªç‰©ï¼`, { 
                        fontSize: '20px', 
                        fill: '#00ff00'
                    }).setOrigin(0.5);
                    
                    this.tweens.add({
                        targets: victoryText,
                        y: victoryText.y - 30,
                        alpha: 0,
                        duration: 1000,
                        onComplete: () => {
                            victoryText.destroy();
                        }
                    });
                }
                
                // æ›´æ–°æ€ªç‰©è¡€é‡é¡¯ç¤º
                this.updateSlimeHealthBar();
            });
        }
    }

    // å‰µå»ºæŠ€èƒ½UIé¡¯ç¤º
    createSkillUI() {
        // ç²å–å¯¦éš›ç•«å¸ƒå°ºå¯¸
        const gameWidth = this.sys.game.config.width;
        const gameHeight = this.sys.game.config.height;
        
        // æŠ€èƒ½ä¸€åœ–æ¨™èˆ‡å†·å»é¡¯ç¤º - éŸ¿æ‡‰å¼ä½ç½®
        this.skill1Icon = this.add.image(gameWidth * 0.875, gameHeight * 0.75, 'skill1').setScale(0.4).setAlpha(0.5);
        this.skill1CooldownText = this.add.text(gameWidth * 0.875, gameHeight * 0.75, '', {
            fontSize: '16px',
            fill: '#ffffff',
            stroke: '#000000',
            strokeThickness: 2
        }).setOrigin(0.5).setVisible(false);
        
        // æŠ€èƒ½äºŒåœ–æ¨™èˆ‡å†·å»é¡¯ç¤º - éŸ¿æ‡‰å¼ä½ç½®
        this.skill2Icon = this.add.image(gameWidth * 0.975, gameHeight * 0.75, 'skill2').setScale(0.4).setAlpha(0.5);
        this.skill2CooldownText = this.add.text(gameWidth * 0.963, gameHeight * 0.75, '', {
            fontSize: '16px',
            fill: '#ffffff',
            stroke: '#000000',
            strokeThickness: 2
        }).setOrigin(0.5).setVisible(false);
        
        // æŠ€èƒ½éµä½æç¤º - éŸ¿æ‡‰å¼ä½ç½®
        this.add.text(gameWidth * 0.875, gameHeight * 0.808, 'Q', {
            fontSize: '16px',
            fill: '#ffffff',
            backgroundColor: '#000000',
            padding: { x: 5, y: 2 }
        }).setOrigin(0.5);
        
        this.add.text(gameWidth * 0.963, gameHeight * 0.808, 'W', {
            fontSize: '16px',
            fill: '#ffffff',
            backgroundColor: '#000000',
            padding: { x: 5, y: 2 }
        }).setOrigin(0.5);
        
        // æ›´æ–°æŠ€èƒ½UIç‹€æ…‹
        this.updateSkillUI();
    }
    
    // æ›´æ–°æŠ€èƒ½UIç‹€æ…‹
    updateSkillUI() {
        // æŠ€èƒ½ä¸€ç‹€æ…‹
        if (this.playerLevel >= 5) {
            // å·²è§£é–æŠ€èƒ½ä¸€
            if (!this.hasSkill1) {
                this.hasSkill1 = true;
                // ç¬¬ä¸€æ¬¡è§£é–æ™‚é¡¯ç¤ºé€šçŸ¥
                this.showSkillUnlockMessage(1);
            }
            this.skill1Icon.setAlpha(1.0);
            
            // é¡¯ç¤ºå†·å»
            const now = this.time.now;
            if (this.lastSkill1Time > 0 && now - this.lastSkill1Time < this.skill1Cooldown) {
                const remainingCooldown = Math.ceil((this.skill1Cooldown - (now - this.lastSkill1Time)) / 1000);
                this.skill1CooldownText.setText(remainingCooldown);
                this.skill1CooldownText.setVisible(true);
                this.skill1Icon.setAlpha(0.6);
            } else {
                this.skill1CooldownText.setVisible(false);
            }
        } else {
            // æœªè§£é–
            this.skill1Icon.setAlpha(0.1);
            this.skill1CooldownText.setText('');
            this.skill1CooldownText.setVisible(true);
            this.skill1CooldownText.setText(`5ç´š`);
        }
        
        // æŠ€èƒ½äºŒç‹€æ…‹
        if (this.playerLevel >= 10) {
            // å·²è§£é–æŠ€èƒ½äºŒ
            if (!this.hasSkill2) {
                this.hasSkill2 = true;
                // ç¬¬ä¸€æ¬¡è§£é–æ™‚é¡¯ç¤ºé€šçŸ¥
                this.showSkillUnlockMessage(2);
            }
            this.skill2Icon.setAlpha(1.0);
            
            // é¡¯ç¤ºå†·å»
            const now = this.time.now;
            if (this.lastSkill2Time > 0 && now - this.lastSkill2Time < this.skill2Cooldown) {
                const remainingCooldown = Math.ceil((this.skill2Cooldown - (now - this.lastSkill2Time)) / 1000);
                this.skill2CooldownText.setText(remainingCooldown);
                this.skill2CooldownText.setVisible(true);
                this.skill2Icon.setAlpha(0.6);
            } else {
                this.skill2CooldownText.setVisible(false);
            }
        } else {
            // æœªè§£é–
            this.skill2Icon.setAlpha(0.1);
            this.skill2CooldownText.setText('');
            this.skill2CooldownText.setVisible(true);
            this.skill2CooldownText.setText(`10ç´š`);
        }
    }
    
    // é¡¯ç¤ºæŠ€èƒ½è§£é–è¨Šæ¯
    showSkillUnlockMessage(skillNumber) {
        // ç²å–å¯¦éš›ç•«å¸ƒå°ºå¯¸
        const gameWidth = this.sys.game.config.width;
        const gameHeight = this.sys.game.config.height;
        
        const skillName = skillNumber === 1 ? 'çˆ†ç‚¸è¡æ“Š' : 'èƒ½é‡å½ˆ';
        const skillKey = skillNumber === 1 ? 'Q' : 'W';
        
        // èƒŒæ™¯é–ƒå…‰æ•ˆæœ
        this.cameras.main.flash(500, 0, 255, 255);
        
        // è§£é–è¨Šæ¯
        const unlockText = this.add.text(gameWidth/2, gameHeight * 0.42, `è§£é–æŠ€èƒ½ï¼š${skillName}ï¼`, {
            fontSize: '36px',
            fill: '#00ffff',
            stroke: '#000000',
            strokeThickness: 4
        }).setOrigin(0.5).setDepth(100);
        
        // ä½¿ç”¨èªªæ˜
        const instructionText = this.add.text(gameWidth/2, gameHeight/2, `æŒ‰ä¸‹ ${skillKey} éµä½¿ç”¨æŠ€èƒ½`, {
            fontSize: '24px',
            fill: '#ffffff',
            stroke: '#000000',
            strokeThickness: 3
        }).setOrigin(0.5).setDepth(100);
        
        // æ·»åŠ æŠ€èƒ½åœ–ç¤º
        const skillIcon = this.add.image(gameWidth/2, gameHeight * 0.58, `skill${skillNumber}`).setScale(0.6).setDepth(100);
        
        // å‹•ç•«æ•ˆæœ
        this.tweens.add({
            targets: [unlockText, instructionText, skillIcon],
            alpha: 0,
            y: '-=30',
            duration: 3000,
            ease: 'Power2',
            delay: 2000,
            onComplete: () => {
                unlockText.destroy();
                instructionText.destroy();
                skillIcon.destroy();
            }
        });
    }
    
    // ä½¿ç”¨æŠ€èƒ½ä¸€ï¼šçˆ†ç‚¸è¡æ“Š
    useSkill1() {
        if (!this.hasSkill1) return; // æœªè§£é–
        
        const now = this.time.now;
        
        // æª¢æŸ¥å†·å»
        if (this.lastSkill1Time > 0 && now - this.lastSkill1Time < this.skill1Cooldown) {
            return; // å†·å»ä¸­
        }
        
        // è¨­ç½®å†·å»æ™‚é–“ï¼š8ç§’
        this.skill1Cooldown = 8000;
        this.lastSkill1Time = now;
        
        // è¨ˆç®—å‚·å®³ï¼ˆåŸºç¤30ï¼Œæ¯ç´š+3ï¼‰
        const damage = 50 + (this.playerLevel * 15);
        
        // å‰µå»ºçˆ†ç‚¸ç‰¹æ•ˆ
        const explosion = this.skillEffects.create(this.player.x, this.player.y, 'skill1').setScale(0.1);
        explosion.damage = damage; // å„²å­˜å‚·å®³å€¼
        
        // çˆ†ç‚¸å‹•ç•«
        this.tweens.add({
            targets: explosion,
            scale: 1.0,
            alpha: { from: 1, to: 0 },
            duration: 800,
            ease: 'Power2',
            onComplete: () => {
                explosion.destroy();
            }
        });
        
        // éœ‡å‹•æ•ˆæœ
        this.cameras.main.shake(300, 0.01);
        
        // å°ç¯„åœå…§çš„æ€ªç‰©é€ æˆå‚·å®³
        this.damageEnemiesInRadius(this.player.x, this.player.y, 300, damage);
        
        // æ›´æ–°UI
        this.updateSkillUI();
    }
    
    // ä½¿ç”¨æŠ€èƒ½äºŒï¼šä¸‰é‡èƒ½é‡å½ˆ
    useSkill2() {
        if (!this.hasSkill2) return; // æœªè§£é–
        
        const now = this.time.now;
        
        // æª¢æŸ¥å†·å»
        if (this.lastSkill2Time > 0 && now - this.lastSkill2Time < this.skill2Cooldown) {
            return; // å†·å»ä¸­
        }
        
        // è¨­ç½®å†·å»æ™‚é–“ï¼š10ç§’
        this.skill2Cooldown = 10000;
        this.lastSkill2Time = now;
        
        // è¨ˆç®—å‚·å®³ï¼ˆåŸºç¤25ï¼Œæ¯ç´š+2.5ï¼‰
        const damage = 100 + (this.playerLevel * 10);
        
        // ç™¼å°„ä¸‰é¡†èƒ½é‡å½ˆ
        const directions = [
            { x: 0, y: -1 },  // æ­£ä¸Šæ–¹
            { x: 0.866, y: 0.5 },  // å³ä¸‹æ–¹ (60åº¦)
            { x: -0.866, y: 0.5 }  // å·¦ä¸‹æ–¹ (120åº¦)
        ];
        
        directions.forEach((dir, index) => {
            // å‰µå»ºèƒ½é‡å½ˆ
            const energyBall = this.skillEffects.create(this.player.x, this.player.y, 'skill2').setScale(0.3);
            energyBall.damage = damage; // å„²å­˜å‚·å®³å€¼
            
            // è¨­ç½®é€Ÿåº¦å’Œæ–¹å‘
            const speed = 300;
            energyBall.setVelocity(dir.x * speed, dir.y * speed);
            
            // è¨­ç½®æ—‹è½‰
            this.tweens.add({
                targets: energyBall,
                rotation: 6.28,
                duration: 1000,
                repeat: -1
            });
            
            // ç™¼å…‰æ•ˆæœ
            energyBall.setTint(0x00ffff);
            
            // èƒ½é‡å½ˆæŒçºŒæ™‚é–“ï¼ˆ2ç§’å¾Œæ¶ˆå¤±ï¼‰
            this.time.delayedCall(2000, () => {
                if (energyBall && energyBall.active) {
                    energyBall.destroy();
                }
            });
            
            // è¨­ç½®ç¢°æ’ï¼šèˆ‡æ€ªç‰©å’ŒBoss
            this.physics.add.overlap(energyBall, this.slimes, (ball, slime) => {
                // å°æ€ªç‰©é€ æˆå‚·å®³
                this.damageEnemy(slime, ball.damage);
                // èƒ½é‡å½ˆæ¶ˆå¤±
                ball.destroy();
            });
            
            // èˆ‡Bossçš„ç¢°æ’
            if (this.boss && this.boss.active) {
                this.physics.add.overlap(energyBall, this.boss, (ball, boss) => {
                    // å°Bossé€ æˆå‚·å®³
                    this.damageBoss(boss, ball.damage);
                    // èƒ½é‡å½ˆæ¶ˆå¤±
                    ball.destroy();
                });
            }
            
            // èˆ‡ç‰†å£ç¢°æ’æ™‚æ¶ˆå¤±
            this.physics.add.collider(energyBall, this.walls, (ball) => {
                ball.destroy();
            });
        });
        
        // æ›´æ–°UI
        this.updateSkillUI();
    }
    
    // å°æŒ‡å®šåŠå¾‘å…§çš„æ•µäººé€ æˆå‚·å®³
    damageEnemiesInRadius(x, y, radius, damage) {
        // å°ç¯„åœå…§çš„æ™®é€šæ€ªç‰©é€ æˆå‚·å®³
        this.slimes.getChildren().forEach(slime => {
            if (slime && slime.active && !slime.isDead) {
                const distance = Phaser.Math.Distance.Between(x, y, slime.x, slime.y);
                if (distance <= radius) {
                    this.damageEnemy(slime, damage);
                }
            }
        });
        
        // å°Bossé€ æˆå‚·å®³ï¼ˆå¦‚æœåœ¨ç¯„åœå…§ï¼‰
        if (this.boss && this.boss.active) {
            const distance = Phaser.Math.Distance.Between(x, y, this.boss.x, this.boss.y);
            if (distance <= radius) {
                this.damageBoss(this.boss, damage);
            }
        }
    }
    
    // å°å–®å€‹æ€ªç‰©é€ æˆå‚·å®³
    damageEnemy(slime, damage) {
        // ç¢ºä¿æ€ªç‰©å­˜åœ¨ä¸”æœ‰è¡€é‡
        if (!slime || !slime.active || typeof slime.slimeHealth === 'undefined' || slime.isDead) {
            return;
        }
        
        // é€ æˆå‚·å®³
        slime.slimeHealth -= damage;
        
        // é¡¯ç¤ºå‚·å®³æ–‡å­—
        const damageText = this.add.text(slime.x, slime.y - 30, damage, { 
            fontSize: '18px', 
            fill: '#ffff00',
            fontStyle: 'bold',
            stroke: '#000000',
            strokeThickness: 2
        }).setOrigin(0.5);
        
        this.tweens.add({
            targets: damageText,
            y: damageText.y - 50,
            alpha: 0,
            duration: 800,
            onComplete: () => {
                damageText.destroy();
            }
        });
        
        // æ€ªç‰©å—å‚·æ•ˆæœ
        slime.setTint(0xffff00);
        setTimeout(() => {
            if (slime && slime.active) {
                slime.clearTint();
            }
        }, 200);
        
        // æª¢æŸ¥æ€ªç‰©æ˜¯å¦æ­»äº¡
        if (slime.slimeHealth <= 0) {
            // æ¨™è¨˜ç‚ºå·²æ­»äº¡
            slime.isDead = true;
            
            // ç«‹å³ç§»é™¤è¡€æ¢
            slime.alpha = 0.9;
            this.updateSlimeHealthBar();
            
            // æ ¹æ“šæ€ªç‰©é¡å‹ç²å¾—ä¸åŒç¶“é©—å€¼
            let expGained = 80;
            if (slime.slimeType === 'å¼·å£¯') {
                expGained = 120;
            } else if (slime.slimeType === 'å¿«é€Ÿ') {
                expGained = 80;
            }
            
            // ç²å¾—ç¶“é©—å€¼
            this.gainExperience(expGained);
            
            // æ€ªç‰©æ­»äº¡æ•ˆæœ
            this.tweens.add({
                targets: slime,
                alpha: 0,
                scale: slime.scale * 0.5,
                duration: 300,
                onComplete: () => {
                    slime.destroy();
                    
                    // éš¨æ©Ÿæ‰è½èƒ½é‡é£²æ–™ (15% å¹¾ç‡)
                    if (this.random.frac() < 0.15) {
                        this.energyIcon.setVisible(true);
                        this.energyPrompt.setVisible(true);
                        
                        // é¡¯ç¤ºæ‰è½æç¤º
                        const dropText = this.add.text(slime.x, slime.y, 'æ‰è½èƒ½é‡é£²æ–™ï¼', { 
                            fontSize: '16px', 
                            fill: '#00ffff'
                        }).setOrigin(0.5);
                        
                        this.tweens.add({
                            targets: dropText,
                            y: dropText.y - 30,
                            alpha: 0,
                            duration: 1500,
                            onComplete: () => {
                                dropText.destroy();
                            }
                        });
                    }
                }
            });
            
            // é¡¯ç¤ºæ“Šæ•—æ–‡å­—
            const victoryText = this.add.text(slime.x, slime.y - 50, `æ“Šæ•—${slime.slimeType}æ€ªç‰©ï¼`, { 
                fontSize: '20px', 
                fill: '#00ff00'
            }).setOrigin(0.5);
            
            this.tweens.add({
                targets: victoryText,
                y: victoryText.y - 30,
                alpha: 0,
                duration: 1000,
                onComplete: () => {
                    victoryText.destroy();
                }
            });
        }
        
        // æ›´æ–°æ€ªç‰©è¡€é‡é¡¯ç¤º
        this.updateSlimeHealthBar();
    }
    
    // å°Bossé€ æˆå‚·å®³
    damageBoss(boss, damage) {
        if (!boss || !boss.active || this.bossDefeated) {
            return;
        }
        
        // é€ æˆå‚·å®³
        boss.bossHealth -= damage;
        
        // é¡¯ç¤ºå‚·å®³æ–‡å­—
        const damageText = this.add.text(boss.x, boss.y - 30, damage, { 
            fontSize: '24px', 
            fill: '#ffff00',
            fontStyle: 'bold',
            stroke: '#000000',
            strokeThickness: 2
        }).setOrigin(0.5);
        
        this.tweens.add({
            targets: damageText,
            y: damageText.y - 50,
            alpha: 0,
            duration: 800,
            onComplete: () => {
                damageText.destroy();
            }
        });
        
        // Bosså—å‚·æ•ˆæœ
        boss.setTint(0xffff00);
        setTimeout(() => {
            if (boss && boss.active) {
                boss.clearTint();
            }
        }, 200);
        
        // æª¢æŸ¥Bossæ˜¯å¦æ­»äº¡
        if (boss.bossHealth <= 0) {
            this.defeatBoss();
        }
        
        // æ›´æ–°Bossè¡€æ¢
        this.updateBossHealthBar();
    }

    // ä½¿ç”¨èƒ½é‡é£²æ–™
    useEnergyDrink() {
        if (!this.energyIcon.visible || this.isGameOver) return;
        
        this.playerHealth += 20;
        if (this.playerHealth > 100) this.playerHealth = 100;
        this.updateHealthBar();
        
        // é¡¯ç¤ºå›å¾©æ•ˆæœ
        const healText = this.add.text(this.player.x, this.player.y - 40, '+20 ç”Ÿå‘½', {
            fontSize: '20px',
            fill: '#00ff00',
            stroke: '#000000',
            strokeThickness: 2
        }).setOrigin(0.5);
        
        this.tweens.add({
            targets: healText,
            y: healText.y - 30,
            alpha: 0,
            duration: 1000,
            onComplete: () => {
                healText.destroy();
            }
        });
        
        this.energyIcon.setVisible(false);
        this.energyPrompt.setVisible(false);
    }
}

// --- éŠæˆ²è¨­å®šï¼Œå•Ÿå‹•å¤§å»³å ´æ™¯ ---
const config = {
    type: Phaser.AUTO,
    width: window.innerWidth,  // ä½¿ç”¨è¦–çª—å¯¬åº¦
    height: window.innerHeight, // ä½¿ç”¨è¦–çª—é«˜åº¦
    pixelArt: true,
    physics: {
        default: 'arcade',
        arcade: { debug: false }
    },
    scene: [LobbyScene, GameScene], // å¤šå ´æ™¯ï¼Œé è¨­å•Ÿå‹• LobbyScene
    scale: {
        mode: Phaser.Scale.RESIZE, // å…è¨±èª¿æ•´å¤§å°
        autoCenter: Phaser.Scale.CENTER_BOTH // å±…ä¸­é¡¯ç¤º
    }
};

// æ·»åŠ è¦–çª—å¤§å°è®ŠåŒ–ç›£è½å™¨
window.addEventListener('resize', () => {
    game.scale.resize(window.innerWidth, window.innerHeight);
});

// æ·»åŠ å…¨å±€éŒ¯èª¤è™•ç†
window.onerror = function(message, source, lineno, colno, error) {
    console.error('éŠæˆ²é‹è¡ŒéŒ¯èª¤:', message, 'åœ¨è¡Œ:', lineno, 'åˆ—:', colno);
    console.error('è©³ç´°éŒ¯èª¤:', error);
    alert('éŠæˆ²ç™¼ç”ŸéŒ¯èª¤ï¼Œè«‹æŸ¥çœ‹æ§åˆ¶å°ç²å–è©³æƒ…');
    return true;
};

const game = new Phaser.Game(config);
</script>
</body>
</html>
