<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>今天吃甚麼?</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@v3.88.2/dist/phaser.js"></script>
    <style>
        * {
            padding: 0;
            margin: 0;
            box-sizing: border-box;
            background-color: black;
        }
    </style>
</head>

<body>
    <script>
        const config = {
            type: Phaser.AUTO,
            width: 1200,
            height: 800,
            backgroundColor: '#aaaaaa',
            scale: { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH },
            physics: {
                default: 'arcade',
                arcade: { gravity: { y: 0 }, debug: false }
            },
            scene: { preload, create, update }
        };
        const game = new Phaser.Game(config);
        let score = 0;
        let scoreText = null;
        //player
        let keys, bombKey;
        let lastFired = 0;
        let hearts = 100, maxHearts = 100;
        let bombs = 5, maxBombs = 5;
        let scoreP = 0;
        let heartIcons = [];
        let uiText = {};
        let toolLeft, toolRight;
        let restartText = null;
        let fabg;
        let playerUpgrades = {
            spread: 1,
            rapid: 0,
            missileCount: 0,
            missileTracking: false,
            missileUpgradeLevel: 0,
        };

        //boss
        let boss1;
        let boss1health = 1000;
        // let gameStarted = false;
        let bulletGroup;
        let attackTimer;
        let attackPhaseTimer;
        let crazyAttackTimer;
        let borderBulletTimer;
        // let player;
        // let cursors;
        let bulletRotationOffset = 0;
        let bossHealthText;
        let bossPhase = 1;
        let boss3;
        let boss3Health = 4000;
        let boss3Phase = 0; // 0未啟動，1~4為四個階段
        let bulletGroup3;
        let boss3MoveActive = false;
        let chainHeadGroup;
        let chainGroup;
        let boss3AllTimers = []; // 儲存所有階段的 timer，方便統一清除
        let allSprites = [];
        let markExplodeGroup;
        let boss2;
        let boss2Health = 3000;
        let boss2Phase = 0; // 0:未啟動, 1~3為階段
        let currentBoss = null;
        let currentBossHealth = 0;
        let boss1bg;
        let boss2bg;
        let boss3bg;
        let atk1;
        let atk2;
        let atk3;
        let BossDeathSound;
        let BossCSound;
        let bossHealthBarBg;
        let bossHealthBar;
        let bossMaxHealth = 1000; // 預設 BOSS1，可根據切換 BOSS 調整
        let deathParticles; // <<< 放到全域變數
        let a = 0;

        let fireSpeed = 250;
        let bulletActive = false;
        // 全域或場景內的變數，若你已有則可省略
        let upgradeTextTitle = null;
        let upgradeChoicePrimary = null;
        let upgradeChoiceSecondary = null;
        let upgradeChoiceRapid = null;
        let UIBG, startButton;

        function preload() {

            this.load.image('bullet1', './bossImgs/bullet.png');
            this.load.spritesheet('boss1', './bossImgs/Boss1待機.png', {
                frameWidth: 1000, frameHeight: 1000
            });
            this.load.image('guy', './bossImgs/guy.png');
             this.load.image('win', './assets/win.png');

            this.load.image('spear', './bossImgs/長茅.png');
            this.load.image('boss2bullet', './bossImgs/鬼火子彈.png');
            this.load.spritesheet('boss2', './bossImgs/ghost 動圖.png', {
                frameWidth: 1000, frameHeight: 956
            });

            this.load.image('markbullet', './bossImgs/mark.png');
            this.load.image('markExplodebullet', './bossImgs/petal.png');
            this.load.image('jumpbullet', './bossImgs/petal.png');
            this.load.image('chainHeadbullet', './bossImgs/mark.png');
            this.load.image('chainbullet', './bossImgs/鎖鏈.png');
            this.load.spritesheet('boss3', './bossImgs/紅女巫.png', {
                frameWidth: 1000, frameHeight: 1000
            });

            this.load.image('deathParticle', './bossImgs/particle.png'); // 類似光球或碎裂特效圖片
            this.load.image('cParticle', './bossImgs/圖層 1.png');

            this.load.audio('boss1bg', './sound/boss1bg.mp3')
            this.load.audio('boss2bg', './sound/boss2bg.mp3')
            this.load.audio('boss3bg', './sound/boss3bg.mp3')

            this.load.audio('atk1', './sound/ATTACK3.mp3')
            this.load.audio('atk2', './sound/ATTACK4.mp3')
            this.load.audio('atk3', './sound/ATTACK5.mp3')
            this.load.audio('BossDeathSound', './sound/DEFEATED.mp3')
            this.load.audio('BossCSound', './sound/TWINKLE.mp3')


            this.load.image("UIBG", "assets/UI.png")
            this.load.image("sky", "assets/第一關/場地/田地2.png");
            this.load.image("sky2", "assets/第二關/場地/墓地.jpg");
            this.load.image("sky3", "assets/第三關/場地/花園.png");

            this.load.image("fabg","assets/fa.png")

            const g = this.add.graphics();
            g.fillStyle(0xff0000, 1);
            g.fillEllipse(bulletsize, bulletsize, bulletsize * 2, bulletsize * 2);
            g.generateTexture('Bullet', bulletsize * 2, bulletsize * 2);
            g.destroy();

            const b = this.add.graphics();
            b.fillStyle(0xff0000, 1);
            b.fillEllipse(bulletsize * 1.5, bulletsize * 1.5, bulletsize * 3, bulletsize * 3);
            b.generateTexture('BIGBullet', bulletsize * 3, bulletsize * 3);
            b.destroy();

            const a = this.add.graphics();
            a.fillStyle(0xff0000, 1);
            a.fillEllipse(bulletsize * 0.4, bulletsize * 6, bulletsize * 0.8, bulletsize * 12);
            a.generateTexture('needle', bulletsize * 0.8, bulletsize * 12);
            a.destroy();

            this.load.image("player", "assets/player/女巫.png");
            this.load.image("playerbullet", "assets/player/玩家子彈.png");
            this.load.image("tool", "assets/player/角色圓環.png");
            this.load.image("heart", "assets/player/愛心.png");
            this.load.image("bomb", "assets/player/炸彈.png");
            this.load.image("new", "assets/player/愛心.png");
            this.load.image("p", "assets/player/p點.png")

            this.load.image("enemy1", "assets/第一關/小怪/豆子.png");
            this.load.image("enemy2", "assets/第一關/小怪/番茄.png");
            this.load.image("enemy3", "assets/第一關/小怪/藤蔓.png");

            this.load.image("enemy4", "assets/第二關/小怪/白鬼.png");
            this.load.image("enemy5", "assets/第二關/小怪/眼球.png");
            this.load.image("enemy6", "assets/第二關/小怪/靈火.png");

            this.load.image("enemy7", "assets/第三關/小怪/掃帚.png");
            this.load.image("enemy8", "assets/第三關/小怪/玩偶.png");
            this.load.image("enemy9", "assets/第三關/小怪/魔法書.png");

            this.load.image("drop1", "assets/drop1.png");
            this.load.image("drop2", "assets/drop2.png");
            this.load.image("drop3", "assets/drop3.png");

            this.load.audio('uibgm', "assets/sound/talk.ogg")
            this.load.audio('bgm1', "assets/第一關/music1.mp3");
            this.load.audio('bgm2', "assets/第二關/music2.mp3");
            this.load.audio('bgm3', "assets/第三關/music3.mp3");

            this.load.audio('enemyShoot', 'assets/sound/shoot.mp3');

        }

        function create() {

            //player
            cursors = this.input.keyboard.createCursorKeys(); // 方向鍵
            keys = this.input.keyboard.addKeys({             // WASD + Z, X
                X: Phaser.Input.Keyboard.KeyCodes.X,
            });
            score = 0;


            this.invincible = false;
            bombKey = keys.X;

            // 顯示主標題文字：「選擇一項能力強化」
            powertext = this.add.text(350, 270, "選擇一項能力強化", { font: "24px Arial", fill: "#ffff00" }).setVisible(false);

            // 定義共用的文字樣式
            const style = { font: "20px Arial", fill: "#ffffff" };

            // 建立三個可點擊的選項文字：導彈、擴散子彈、連射
            spreadShot = this.add.text(350, 300, "▶ 主子彈 +1", style).setInteractive().setVisible(false);
            missileUpgrade = this.add.text(350, 330, "▶ 副子彈 +1", style).setInteractive().setVisible(false);
            rapidFire = this.add.text(350, 360, "▶ 提高連射速度", style).setInteractive().setVisible(false);

            // 定義一個共用的函數，當選擇任一能力後，移除所有選項並開始主遊戲
            const startGame = () => {
                spreadShot.setVisible(false);      // 移除擴散子彈選項
                missileUpgrade.setVisible(false);  // 移除導彈選項
                rapidFire.setVisible(false);       // 移除連射速度選項
                powertext.setVisible(false);
            };



            // 當玩家點擊導彈選項
            missileUpgrade.on('pointerdown', () => {
                playerUpgrades.missileCount += 1;           // 設定初始導彈數為1
                playerUpgrades.missileUpgradeLevel += 1;    // 導彈升級等級設為1
                startGame();                               // 開始遊戲
            });



            // 當玩家點擊連射速度選項
            rapidFire.on('pointerdown', () => {
                fireSpeed -= 50; // 啟用快速射擊模式
                startGame();                 // 開始遊戲
            });

            // this.input.keyboard.on('keydown-FOUR', () => {
            //     showUpgradeOptions()
            // });
            // boss
            bulletGroup = this.physics.add.group();
            cursors = this.input.keyboard.createCursorKeys();

            // 建立血條背景（紅色）
            bossHealthBarBg = this.add.rectangle(400, 20, 300, 20, 0xff0000).setOrigin(0.5, 0.5).setVisible(false);

            // 建立血條本體（綠色）
            bossHealthBar = this.add.rectangle(400, 20, 300, 20, 0x00ff00).setOrigin(0.5, 0.5).setVisible(false);

            boss1bg = this.sound.add('boss1bg', { loop: true, volume: 0.5 });
            boss1bg.loop = true;
            boss2bg = this.sound.add('boss2bg', { loop: true, volume: 0.5 });
            boss2bg.loop = true;
            boss3bg = this.sound.add('boss3bg', { loop: true, volume: 0.5 });
            boss3bg.loop = true;

            atk1 = this.sound.add('atk1', { volume: 0.05 });
            atk2 = this.sound.add('atk2', { volume: 0.05 });
            atk3 = this.sound.add('atk3', { volume: 0.05 });

            BossDeathSound = this.sound.add('BossDeathSound', { volume: 0.05 });
            BossCSound = this.sound.add('BossCSound', { volume: 0.05 });


            this.anims.create({
                key: 'boss1待機',
                frames: this.anims.generateFrameNumbers('boss1', { start: 0, end: 3 }),
                frameRate: 6,
                repeat: -1
            });
            this.anims.create({
                key: 'boss1攻擊',
                frames: this.anims.generateFrameNumbers('boss1', { start: 4, end: 8 }),
                frameRate: 8,
                repeat: -1
            });
            this.anims.create({
                key: 'boss1鑽出地',
                frames: this.anims.generateFrameNumbers('boss1', { start: 10, end: 14 }),
                frameRate: 10,
                repeat: 0
            });
            this.anims.create({
                key: 'boss1鑽入地',
                frames: this.anims.generateFrameNumbers('boss1', { start: 14, end: 9 }),
                frameRate: 10,
                repeat: 0
            });

            this.anims.create({
                key: 'boss2待機',
                frames: this.anims.generateFrameNumbers('boss2', { start: 0, end: 2 }),
                frameRate: 6,
                repeat: -1
            });
            this.anims.create({
                key: 'boss2攻擊',
                frames: this.anims.generateFrameNumbers('boss2', { start: 3, end: 3 }),
                frameRate: 6,
                repeat: -1
            });
            this.anims.create({
                key: 'boss2衝刺',
                frames: this.anims.generateFrameNumbers('boss2', { start: 4, end: 4 }),
                frameRate: 6,
                repeat: -1
            });

            this.anims.create({
                key: 'boss3待機',
                frames: this.anims.generateFrameNumbers('boss3', { start: 1, end: 3 }),
                frameRate: 3,
                repeat: -1
            });
            this.anims.create({
                key: 'boss3攻擊',
                frames: this.anims.generateFrameNumbers('boss3', { start: 4, end: 3 }),
                frameRate: 2,
                repeat: -1
            });
            this.anims.create({
                key: 'boss3轉身',
                frames: this.anims.generateFrameNumbers('boss3', { start: 6, end: 10 }),
                frameRate: 6,
                repeat: 0
            });
            this.anims.create({
                key: 'boss3轉身0',
                frames: this.anims.generateFrameNumbers('boss3', { start: 6, end: 6 }),
                frameRate: 6,
                repeat: 0
            });
            spearGroup = this.physics.add.group();
            this.bossBeingSpawned = false;

            this.input.keyboard.on('keydown-P', () => {
                reduceBossHealth(110, this);

            });
            //UI
            const UIBG = this.add.image(600, 400, 'UIBG').setOrigin(0.5).setDepth(-1).setScale(1);


            // 開始按鈕
            const startButton = this.add.text(600, 400 + 200, '開始', {
                fontFamily: 'Arial',
                fontSize: '36px',
                color: '#ffffff',
                backgroundColor: '#4444aa',
                padding: { x: 20, y: 10 },

            }).setOrigin(0.5).setInteractive();

            [startButton].forEach(button => {
                button.on('pointerover', () => button.setStyle({ backgroundColor: '#6666cc' }));
                button.on('pointerout', () => button.setStyle({ backgroundColor: '#4444aa' }));
            });

            //遊戲場景
            this.bg = this.add.tileSprite(0, 0, 0, 1200, stages[stageIndex].bgKey)
                .setOrigin(0, 0)
                .setDepth(-1)
                .setScrollFactor(0)
                .setDisplaySize(800, 800)
                .setVisible(false);
            // 設定世界邊界
            this.physics.world.setBounds(0, 0, 800, 800);
            this.mark = this.add.rectangle(800, 0, 400, 1200)
                .setOrigin(0, 0)
                .setScrollFactor(0)
                .setDepth(999)
                .setVisible(false);
            this.scrollingBackground = false;

            //角色移動
            cursors = this.input.keyboard.createCursorKeys();
            keyA = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A);
            keyS = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S);
            keyD = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D);
            keyW = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W);
            keyX = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.X);
            keySpace = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
            this.lastShotTime = 0;

            this.controlEnabled = false;

            //角色
            player = this.physics.add.sprite(400, 900, "player").setScale(0.1);
            player.setSize(70, 70).setOffset(player.width / 2 - 30, player.height / 2 - 30);
            player.setCollideWorldBounds(false);
            player.setVisible(false);

            toolLeft = this.physics.add.image(player.x - 60, player.y, 'tool').setVisible(false).setScale(0.4);
            toolRight = this.physics.add.image(player.x + 60, player.y, 'tool').setVisible(false).setScale(0.4);
            toolLeft.body.allowGravity = false;
            toolRight.body.allowGravity = false;

            // 子彈群組，方便管理所有玩家子彈
            playerBullets = this.physics.add.group({
                defaultKey: 'playerbullet'
            });

            /* 子彈與敵人群組 */
            bullets = this.physics.add.group();
            enemies = this.physics.add.group();

            this.physics.add.overlap(player, bullets, onPlayerHit, null, this);
            this.physics.add.overlap(playerBullets, enemies, bulletHitEnemy, null, this);

            /*音樂*/
            this.stageMusic = [
                this.sound.add('bgm1', { loop: true, volume: 0.5 }),
                this.sound.add('bgm2', { loop: true, volume: 0.5 }),
                this.sound.add('bgm3', { loop: true, volume: 0.5 })
            ];
            this.currentMusic = null;
            this.currentMusic = this.sound.add('uibgm', { loop: true, volume: 0.5 });
            this.currentMusic.play();
            startButton.setInteractive().on('pointerdown', () => {
                // 先隱藏主畫面 UI
                UIBG.destroy();

                startButton.destroy();

                // 顯示玩家生命（心型圖示）
                for (let i = 0; i < maxHearts; i++) {
                    let heart = this.add.image(860 + i * 32, 50, 'heart').setScrollFactor(0).setScale(0.03);
                    heartIcons.push(heart); // 存入陣列方便後續操作
                }

                // 顯示炸彈數量與 P 點數（UI 文字）
                uiText.bombs = this.add.text(850, 100, `BOMB: ${bombs}/${maxBombs}`, { font: "18px Arial", fill: "#000000" });
                uiText.p = this.add.text(850, 150, `P點數: ${scoreP}`, { font: "18px Arial", fill: "#000000" });
                scoreText = this.add.text(850, 200, 'Score: 0', {
                    fontFamily: 'Arial',
                    fontSize: '28px',
                    color: '#000000'
                }).setScrollFactor(0).setDepth(1);

                // 顯示遊戲場景元素但先不啟動 physics
                this.bg.setVisible(true);
                player.setVisible(true);
                this.mark.setVisible(true);

                // 這裡先暫停遊戲
                pauseGame(this);
                // 播放音樂、開始入場動畫
                playStageMusic.call(this, stageIndex);
                // 彈出升級選單，玩家選完後才真正進入入場動畫
                showUpgradeMenu(this, (choice) => {
                    // choice 可能是 "primary"、"secondary"、"rapid"
                    if (choice === "primary") {
                        playerUpgrades.spread += 1;
                        toolLeft.setVisible(true);
                        toolRight.setVisible(true);
                    } else if (choice === "secondary") {
                        playerUpgrades.missileCount += 1;
                        playerUpgrades.missileUpgradeLevel += 1;
                    } else if (choice === "rapid") {
                        fireSpeed -= 50;
                    }

                    // 選完之後，resumeGame() 已在 closeUpgradeMenu() 裡呼叫
                    // 所以緊接著就可以跑「入場動畫 → 生成第 1 波」的原本流程

                    // （a）先放開物理並進行入場動畫
                    this.physics.world.enable(player);
                    this.controlEnabled = false;
                    this.tweens.add({
                        targets: player,
                        y: 680,
                        duration: 3000,
                        ease: 'Quart.easeInOut',
                        onComplete: () => {
                            player.setCollideWorldBounds(true);
                            this.controlEnabled = true;
                        }
                    });
                    this.tweens.add({
                        targets: this.bg,
                        tilePositionY: this.bg.tilePositionY - 1200,
                        duration: 3000,
                        ease: 'Sine.easeInOut',
                        onComplete: () => {
                            // 解除暫停 → 實際上 resumeGame() 已經叫過
                            // 現在執行 spawnWave & waveIndex++
                            spawnWave.call(this, waveDataone[waveIndex]);
                            waveIndex++;
                        }
                    });
                });
            });

            // 當玩家點擊擴散子彈選項
            spreadShot.on('pointerdown', () => {
                playerUpgrades.spread += 1;  // 增加擴散子彈數量（+2）


                toolLeft.setVisible(true);
                toolRight.setVisible(true);
                startGame(); // 開始遊戲
            });
            this.items = this.physics.add.group();

        }

        function update(time) {

            // 工具（tool）跟隨玩家移動
            if (toolLeft) toolLeft.setPosition(player.x - 70, player.y);
            if (toolRight) toolRight.setPosition(player.x + 70, player.y);

            // 使用炸彈：按下 X 鍵，清空畫面上的子彈，並造成畫面震動效果
            if (Phaser.Input.Keyboard.JustDown(bombKey) && bombs > 0) {
                clearAllBullets(this);
                bullets.children.each(b => { b.destroy(); });
                this.cameras.main.shake(200, 0.01); // 畫面震動
                bombs--; // 減少炸彈數量
                uiText.bombs.setText(`BOMB: ${bombs}/${maxBombs}`); // 更新 UI 顯示
                playBoomEffect(this);

            }
            //boss
            // —— Boss1 进场 & 行为逻辑 —— 
            if (boss1 && boss1.body) {
                if (boss1.y >= 150 && boss1.body.velocity.y !== 0) {
                    boss1.setVelocityY(0);
                    boss1.y = 150;
                    startBossAttack();
                }
                if (boss1.active && boss1health !== currentBossHealth) {
                    currentBossHealth = boss1health;
                    updateBossHealthBar(boss1health);
                }
            }
            if (boss2 && boss2.y >= 150 && boss2.body.velocity.y !== 0 && boss2Phase == 1) {
                boss2.setVelocityY(0);
                boss2.y = 150;
                startBoss2Attack.call(this); // 開始 Boss2 攻擊
                console.log("0000000000")
            }

            if (boss2 && boss2Phase == 1) {
                if (boss2.y >= 150 && boss2.body.velocity.y !== 0) {
                    boss2.setVelocityY(0);
                    boss2.y = 150;
                    startBoss2Phase1(this);
                    console.log("0")
                }

                updateBoss2Behavior(this);
            }
            if (boss2 && boss2Phase == 3) {
                boss2.anims.play('boss2衝刺', true);
                if (boss2.body.velocity.x < 0) {
                    boss2.setFlipX(true); // 向左移動，翻轉圖片
                } else if (boss2.body.velocity.x > 0) {
                    boss2.setFlipX(false); // 向右移動，圖片恢復
                }
            }
            if (a == 0)
                if (boss3 && boss3.y >= 150 && boss3.body.velocity.y !== 0) {
                    boss3.setVelocityY(0);
                    boss3.y = 150;
                    console.log("BOSS3 就位");
                    startBoss3Phase1(this);// 可在這裡呼叫第一階段攻擊
                    a++;
                }

            if (boss3 && boss3.active) {
                updateBoss3Behavior(this);
            }

            bulletGroup.children.iterate(bullet => {
                if (bullet) {
                    if (bullet.isReboundBullet) {
                        // 是反彈子彈
                        if (bullet.body.blocked.left || bullet.body.blocked.right ||
                            bullet.body.blocked.up || bullet.body.blocked.down) {
                            bullet.bounceCount++;
                            if (bullet.bounceCount >= 2) {
                                bullet.destroy();
                            }
                        }
                    } else {
                        // 一般子彈才用超出範圍刪除
                        if (bullet.x < -50 || bullet.x > 850 || bullet.y < -50 || bullet.y > 850) {
                            bullet.destroy();
                        }
                    }
                }
            });

            if (markExplodeGroup) {
                markExplodeGroup.children.each(bullet => {
                    if (bullet.active && bullet.update) bullet.update();
                });
            }
            if (boss1 && boss1.active && boss1health !== currentBossHealth) {
                currentBossHealth = boss1health;
                updateBossHealthBar(boss1health);
            } else if (boss2 && boss2.active && boss2Health !== currentBossHealth) {
                currentBossHealth = boss2Health;
                updateBossHealthBar(boss2Health);
            } else if (boss3 && boss3.active && boss3Health !== currentBossHealth) {
                currentBossHealth = boss3Health;
                updateBossHealthBar(boss3Health);
            }
            updateBossBehavior(this);

            /* -------- 玩家移動（有控制權時才讀鍵盤） -------- */
            let vx = 0, vy = 0;
            if (this.controlEnabled) {
                if (keyA.isDown || cursors.left.isDown) vx -= 1;
                if (keyD.isDown || cursors.right.isDown) vx += 1;
                if (keyW.isDown || cursors.up.isDown) vy -= 1;
                if (keyS.isDown || cursors.down.isDown) vy += 1;
            }
            const len = Math.hypot(vx, vy);
            if (len) { vx = (vx / len) * speed; vy = (vy / len) * speed; }
            player.setVelocity(vx, vy);
            if (this.scrollingBackground) {
                this.bg.tilePositionY -= 2;
            }
            if (this.controlEnabled) {
                if (keySpace.isDown && time > this.lastShotTime + fireSpeed) { // 200毫秒冷卻
                    shootPlayerBullet.call(this);
                    this.lastShotTime = time;
                }
            }

            enemies.children.iterate(enemy => {
                if (!enemy.active || !enemy.ready) return;
                if (time > enemy.lastShot + enemy.shootCooldown) {
                    enemy.lastShot = time;
                    if (enemy.type === 'a') enemy1AtPlayer.call(this, enemy);
                    if (enemy.type === 'b') enemy2AtPlayer.call(this, enemy);
                    if (enemy.type === 'c') enemy3AtPlayer.call(this, enemy);
                    if (enemy.type === 'd') enemy4AtPlayer.call(this, enemy);
                    if (enemy.type === 'e') enemy5AtPlayer.call(this, enemy);
                    if (enemy.type === 'f') enemy6AtPlayer.call(this, enemy);
                    if (enemy.type === 'g') enemy7AtPlayer.call(this, enemy);
                    if (enemy.type === 'h') enemy8AtPlayer.call(this, enemy);
                    if (enemy.type === 'i') enemy9AtPlayer.call(this, enemy);
                }
            });

            playerBullets.children.each(playbulltes => {
                if (!playbulltes.active) return;
                if (playbulltes.x < -50 || playbulltes.x > 800 || playbulltes.y < -50 || playbulltes.y > 800) {
                    this.tweens.killTweensOf(playbulltes);
                    playbulltes.destroy();
                }
            });

            bullets.children.each(b => {
                if (!b.active) return;
                if (b.x < -50 || b.x > 800 || b.y < -50 || b.y > 800) {
                    this.tweens.killTweensOf(b);
                    b.destroy();
                }
                // S型子彈移動
                if (b.getData('amplitude')) {
                    const timeOffset = b.getData('timeOffset');
                    const amplitude = b.getData('amplitude');
                    const frequency = b.getData('frequency');
                    const offsetX = Math.sin((time - timeOffset) * frequency) * amplitude;
                    b.x = b.getData('startX') + offsetX;
                }
                if (b.getData('following')) {
                    const offsetX = b.getData('offsetX');
                    const followEnemy = b.getData('followEnemy');
                    b.x = followEnemy.x + offsetX;
                    b.y = followEnemy.y;

                    const dx = player.x - b.x;
                    const dy = player.y - b.y;
                    const angle = Math.atan2(dy, dx);
                    b.rotation = angle + Math.PI / 2;
                }
                if (b.getData('semiTracking')) {
                    const dx = player.x - b.x;
                    const dy = player.y - b.y;
                    const dist = Math.hypot(dx, dy);
                    const maxTrackingDist = 80;

                    if (dist <= maxTrackingDist) {
                        const angle = Math.atan2(dy, dx);
                        const currentAngle = Math.atan2(b.body.velocity.y, b.body.velocity.x);
                        const turnRate = 0.01;
                        const newAngle = Phaser.Math.Angle.RotateTo(currentAngle, angle, turnRate);
                        const speed = 150;

                        b.setVelocity(Math.cos(newAngle) * speed, Math.sin(newAngle) * speed);
                        b.rotation = newAngle;
                    }
                }
            });

            /* 檢查本波是否清空（可以進入下一波） */
            if (enemies.countActive(true) === 0 && !lastWaveCleared) {
                lastWaveCleared = true;
                console.log('--- 波次清除，按 K 進下一波 ---');
            }

            // ★★★ 道具的磁吸效果 ★★★
            this.items.children.iterate(item => {
                if (item && item.active) {
                    const isEjected = item.getData('ejected');
                    if (!isEjected) {
                        // 噴射結束後，用 600 的速度吸向玩家（你可調整這個數值）
                        this.physics.moveToObject(item, player, 600);
                    }
                    // 如果 isEjected === true，就維持它當前的 velocity，不改動
                }
            });



        }

        // 全域變數或 scene 內都能使用
        function pauseGame(scene) {
            // 停止玩家輸入
            scene.controlEnabled = false;

            // 暫停物理世界（所有碰撞、移動都暫停）
            scene.physics.world.pause();

            // 暫停所有正在跑的 Tween
            scene.tweens.pauseAll();

            // 暫停所有正在跑的定時事件 (time events)
            scene.time.paused = true;
        }

        function resumeGame(scene) {
            // 恢復玩家輸入
            scene.controlEnabled = true;

            // 恢復物理世界
            scene.physics.world.resume();

            // 恢復所有 Tween
            scene.tweens.resumeAll();

            // 恢復所有定時器
            scene.time.paused = false;
        }

        function spawnWave(wave) {
            /* 1. 背景先滑動，再進入產生敵人 */
            this.tweens.add({
                targets: this.bg,
                tilePositionY: this.bg.tilePositionY - 1800,
                duration: 2000,
                ease: 'linear',
                onComplete: () => {

                    console.log(`▶ 生成波 ${waveIndex}`);
                    wave.forEach(d => {
                        let tex = '', cooldown = 0, hp = 0;
                        if (d.type === 'a') { tex = 'enemy1'; cooldown = 1500; hp = 80; }
                        if (d.type === 'b') { tex = 'enemy2'; cooldown = 2600; hp = 80; }
                        if (d.type === 'c') { tex = 'enemy3'; cooldown = 5000; hp = 80; }
                        if (d.type === 'd') { tex = 'enemy4'; cooldown = 1000; hp = 80; }
                        if (d.type === 'e') { tex = 'enemy5'; cooldown = 2400; hp = 130; }
                        if (d.type === 'f') { tex = 'enemy6'; cooldown = 1500; hp = 60; }
                        if (d.type === 'g') { tex = 'enemy7'; cooldown = 5000; hp = 130; }
                        if (d.type === 'h') { tex = 'enemy8'; cooldown = 4000; hp = 100; }
                        if (d.type === 'i') { tex = 'enemy9'; cooldown = 2800; hp = 80; }

                        if (stageIndex === 0) {
                            const tmp = this.add.sprite(0, 0, tex).setScale(0.05);
                            const w = tmp.displayWidth, h = tmp.displayHeight;
                            tmp.destroy();

                            const startY = d.y + h;
                            const enemy = enemies.create(d.x, startY, tex).setScale(0.05);
                            Object.assign(enemy, { type: d.type, shootCooldown: cooldown, lastShot: 0, ready: false, hp: hp });

                            const g = this.make.graphics();
                            g.fillStyle(0xffffff).fillRect(d.x - w / 2, d.y - h / 2, w, h);
                            enemy.setMask(g.createGeometryMask());

                            this.tweens.add({
                                targets: enemy,
                                y: d.y,
                                duration: 1000,
                                ease: 'Sine.easeOut',
                                onUpdate: () => { enemy.x = d.x + Phaser.Math.Between(-2, 2); },
                                onComplete: () => {
                                    enemy.setPosition(d.x, d.y);
                                    enemy.clearMask(true);
                                    g.destroy();
                                    enemy.ready = true;
                                }
                            });
                        }

                        /* === B. 第二關：從畫面外飛入指定位置 ====================== */
                        else if (stageIndex === 1) {
                            // 取得畫面外隨機起點
                            const { x: sx, y: sy } = getOffScreenPos();
                            const enemy = enemies.create(sx, sy, tex).setScale(0.05);
                            Object.assign(enemy, { type: d.type, shootCooldown: cooldown, lastShot: 0, ready: false, hp: hp });

                            // 飛到目標
                            this.tweens.add({
                                targets: enemy,
                                x: d.x,
                                y: d.y,
                                duration: 1200,
                                ease: 'Sine.easeOut',
                                onComplete: () => { enemy.ready = true; }
                            });
                        }

                        else if (stageIndex === 2) {
                            // 取得畫面外隨機起點
                            const { x: sx, y: sy } = getOffScreenPos();
                            const enemy = enemies.create(sx, sy, tex).setScale(0.05);
                            Object.assign(enemy, { type: d.type, shootCooldown: cooldown, lastShot: 0, ready: false, hp: hp });

                            // 飛到目標
                            this.tweens.add({
                                targets: enemy,
                                x: d.x,
                                y: d.y,
                                duration: 1200,
                                ease: 'Sine.easeOut',
                                onComplete: () => { enemy.ready = true; }
                            });
                        }
                    });

                    lastWaveCleared = false;
                }
            });
        }

        function clearCurrentWave() {
            // 停止子彈 tween 並銷毀
            bullets.getChildren().forEach(b => {
                this.tweens.killTweensOf(b);
                b.destroy();
            });

            // 清除敵人
            enemies.clear(true, true);

            // 子彈群組也清空
            bullets.clear(true, true);

            lastWaveCleared = true;
        }

        function onPlayerHit(player, bullet) {
            this.tweens.killTweensOf(bullet);
            bullet.destroy();
            player.setTintFill(0xff0000);
            this.time.delayedCall(80, () => player.clearTint());
            console.log("玩家被擊中！");

            // 若目前為無敵狀態或玩家生命已歸零，則不執行碰撞處理
            if (this.invincible || hearts <= 0) return;

            hearts--;         // 玩家生命減一
            updateHearts();   // 更新畫面上的愛心顯示

            // 若生命歸零，觸發 Game Over 流程
            if (hearts <= 0) {
                player.setTint(0xff0000);       // 將玩家染紅表示死亡
                this.physics.pause();           // 停止整體物理運算（敵人、攻擊物等都會靜止）
                this.currentMusic.stop();
                this.controlEnabled = false; // 禁止操作
                showRestartText.call(this); // 顯示「點擊重新開始」
                return;
            }

            // 若未死亡，進入無敵狀態
            this.invincible = true;
            player.setAlpha(0.5); // 設定半透明顯示效果（視覺提示：受到攻擊）

            // 在無敵狀態中閃爍效果：在 0.5 秒內變換透明度
            this.time.addEvent({
                delay: 500,           // 閃爍間隔 500 毫秒
                repeat: 1,            // 重複 1 次（閃爍兩次）
                callback: () => player.setAlpha(player.alpha === 1 ? 0.5 : 1) // 交替透明與不透明
            });

            // 1 秒後解除無敵並恢復玩家不透明
            this.time.delayedCall(1000, () => {
                this.invincible = false; // 解除無敵狀態
                player.setAlpha(1);      // 恢復正常顯示
            });

        }

        function bulletHitEnemy(playerbullet, enemy) {
            this.tweens.killTweensOf(playerbullet);
            playerbullet.destroy();
            enemy.setTintFill(0xff0000);
            this.time.delayedCall(80, () => enemy.clearTint());
            enemy.hp -= 5;

            score += 1000;
            if (scoreText) {
                scoreText.setText(`Score: ${score}`);
            }

            if (enemy.hp <= 0) {
                // 记录掉落位置
                const dropX = enemy.x;
                const dropY = enemy.y;

                // 8% 机率掉 1 个 P 点
                if (Math.random() < 0.05) {
                    const pItem = this.items.create(dropX, dropY, 'p').setData('type', 'p').setScale(0.03);
                    pItem.body.allowGravity = false;
                    this.physics.add.overlap(player, pItem, handleItem, null, this);
                }

                // 最后销毁小怪
                enemy.destroy();

                // 检查整波是否清空
                if (enemies.countActive(true) === 0) {
                    lastWaveCleared = true;
                    nextWave.call(this);
                }
            }
        }

        // 召喚「當前關卡的 Boss」
        // 參數 scene 是 Phaser 的 this；根據 stageIndex 不同產生對應的 boss
        function spawnCurrentStageBoss(scene) {
            if (scene.currentMusic) {
                scene.currentMusic.stop();
                // （也可以選擇 scene.currentMusic.destroy(); 但 stop() 就能暫停）
            }
            // 先把場上所有小怪、子彈清掉
            enemies.clear(true, true);
            bullets.clear(true, true);
            lastWaveCleared = false;

            if (stageIndex === 0) {
                boss1bg.play();
                boss1 = scene.physics.add.sprite(400, -100, 'boss1').setVelocityY(100).setScale(0.09);
                boss1.anims.play('boss1待機', true);
                scene.physics.add.overlap(player, bulletGroup, onPlayerHit, null, scene);
                scene.physics.add.overlap(boss1, bulletGroup, bulletHitBoss, null, scene); // << 加這行！！
                scene.physics.add.overlap(boss1, playerBullets, (bullet, boss) => {
                    boss.destroy(); // 撞到後先銷毀子彈
                    reduceBossHealth(3 + scoreP, scene); // 正確觸發扣血
                    score += 1000;
                    if (scoreText) {
                        scoreText.setText(`Score: ${score}`);
                    }
                    if (boss1health <= 0) {
                        onBossDeath(scene, 1);
                    }
                }, null, scene);
                /*  
                 */
                boss1health = 1000;
                bossHealthBar.setVisible(true);
                bossHealthBarBg.setVisible(true);
                bossMaxHealth = 1000; // <<< 設定最大血量

            } else if (stageIndex === 1) {
                switchToBoss2(scene);  // 傳入 scen
                boss2bg.play();
                scene.physics.add.overlap(boss2, playerBullets, (bullet, boss) => {
                    boss.destroy(); // 撞到後先銷毀子彈
                    reduceBossHealth(3 + scoreP, scene); // 正確觸發扣血
                    if (boss2Health <= 0) {
                        onBossDeath(scene, 2);
                    }
                }, null, scene);

            } else if (stageIndex === 2) {
                switchToBoss3(scene);  // 切換到 BOSS3，並傳入 scene
                boss3bg.play();
                scene.physics.add.overlap(boss3, playerBullets, (bullet, boss) => {
                    boss.destroy(); // 撞到後先銷毀子彈
                    reduceBossHealth(3 + scoreP, scene); // 正確觸發扣血
                    if (boss3Health <= 0) {
                        onBossDeath(scene, 3);
                    }
                }, null, scene);
            }
        }

        function onBossDeath(scene, bossNum) {
            let x = 0, y = 0;

            // 先记录并销毁对应的 boss 实例
            if (bossNum === 1 && boss1) {
                x = boss1.x; y = boss1.y;
                boss1.destroy();
                boss1 = null;
                boss1bg.stop();
            }
            if (bossNum === 2 && boss2) {
                x = boss2.x; y = boss2.y;
                boss2.destroy();
                boss2 = null;
                boss2bg.stop();
            }
            if (bossNum === 3 && boss3) {
                x = boss3.x; y = boss3.y;
                boss3.destroy();
                boss3 = null;
                boss3bg.stop();
            }

            // 播放 Boss 死亡特效
            playBossDeathEffect(scene, x, y);

            // --------------- 掉落道具：先往不同方向噴射 ---------------
            // 按需求：3 個 'p'、1 個 'new'（heart）、1 個 'bomb'，總共 5 個
            const flatDrops = [
                { key: 'p', type: 'p' },
                { key: 'new', type: 'new' },
                { key: 'bomb', type: 'bomb' }
            ];

            // 先算出 5 個互不相同、平均分佈的角度（單位：弧度）
            const angles = [];
            const total = flatDrops.length;
            for (let i = 0; i < total; i++) {
                angles.push(Phaser.Math.DegToRad((360 / total) * i));
            }


            flatDrops.forEach((drop, idx) => {
                const angle = angles[idx];
                const ejectSpeed = 200; // 噴射速度，可以自行調整

                // 建立道具精靈並設置 data 標記「ejected」= true
                const item = scene.items.create(x, y, drop.key)
                    .setData('type', drop.type)
                    .setData('ejected', true)
                    .setScale(0.03); // 如果要縮小，可以在這裡調整比例
                item.body.allowGravity = false;

                // 用 angle 決定噴射初速度
                scene.physics.velocityFromRotation(angle, ejectSpeed, item.body.velocity);

                // 綁定拾取回呼
                scene.physics.add.overlap(player, item, handleItem, null, scene);

                // 500ms 後結束「噴射狀態」，改成被吸引
                scene.time.delayedCall(500, () => {
                    item.setData('ejected', false);
                    item.body.setVelocity(0, 0);
                });
            });

            // 隐藏并重置血条
            bossHealthBar.setVisible(false);
            bossHealthBarBg.setVisible(false);

            // 重置为可再次触发召唤下一关 Boss
            scene.bossBeingSpawned = false;

            const justClearedStage = stageIndex;

            // 接著讓 stageIndex +1，代表要「進入下一關」
            stageIndex++;

            // 如果剛剛打的是第三關（justClearedStage === 2），就不要彈升級選單，直接進入下一步（通關 or 下一關）
            if (justClearedStage === 2) {
                // 0.5 秒後回主畫面
                 win = scene.add.image(400,200,'win').setOrigin(0.5).setDepth(-1).setScale(0.3);
                /*
                scene.time.delayedCall(500, () => {
                    showMainMenu(scene);
                });*/
            }
            else {
                // 對於「第一關的 Boss1 (justClearedStage=0)」和「第二關的 Boss2 (justClearedStage=1)」，都要先暫停並彈升級選單
                pauseGame(scene);
                showUpgradeMenu(scene, (choice) => {
                    // 玩家選完升級後，根據 choice 給予加成
                    if (choice === "primary") {
                        playerUpgrades.spread += 1;
                        toolLeft.setVisible(true);
                        toolRight.setVisible(true);
                    }
                    else if (choice === "secondary") {
                        playerUpgrades.missileCount += 1;
                        playerUpgrades.missileUpgradeLevel += 1;
                    }
                    else if (choice === "rapid") {
                        fireSpeed -= 50;
                    }

                    // closeUpgradeMenu() 內會呼 resumeGame(scene)
                    // 選完後就進下一關
                    enterNextStage.call(scene);
                });
            }
        }
        // 最後修改 nextWave()：當 waveIndex >= 本關波數長度，先自動召 Boss，不直接進關
        function nextWave() {
            const curStage = stages[stageIndex];

            if (waveIndex < curStage.waves.length) {
                // 還有波次就繼續
                spawnWave.call(this, curStage.waves[waveIndex]);
                waveIndex++;
            } else {
                // 本關小怪已經打完
                if (!this.bossBeingSpawned) {
                    this.bossBeingSpawned = true;   // 標記已經進入「召 Boss」階段
                    spawnCurrentStageBoss(this);
                }
            }
        }
        function enterNextStage() {

            waveIndex = 0;
            playStageMusic.call(this, stageIndex);

            // 切換背景
            const nextStage = stages[stageIndex];
            this.bg.setTexture(nextStage.bgKey);
            this.bg = this.add.tileSprite(0, 0, 0, 3000, nextStage.bgKey)
                .setOrigin(0, 0)
                .setDepth(-1)
                .setScrollFactor(0)
                .setDisplaySize(800, 800);
            this.bg.tilePositionY = 0;

            // 更新是否滾動背景
            if (stageIndex === 1 || stageIndex === 2) {
                this.scrollingBackground = true;
            } else {
                this.scrollingBackground = false;
            }

            // 進下一關前，重置 bossBeingSpawned
            this.bossBeingSpawned = false;

            // 生成下一關第 1 波
            spawnWave.call(this, nextStage.waves[waveIndex]);
            waveIndex++;
        }
        function getOffScreenPos() {
            const margin = 50;          // 離螢幕邊緣一小段
            const side = Phaser.Math.Between(0, 3); // 0:上 1:下 2:左 3:右
            switch (side) {
                case 0: return { x: Phaser.Math.Between(0, 600), y: -margin };      // 上
                case 1: return { x: Phaser.Math.Between(0, 600), y: 800 + margin }; // 下
                case 2: return { x: -margin, y: Phaser.Math.Between(0, 800) }; // 左
                default: return { x: 600 + margin, y: Phaser.Math.Between(0, 800) }; // 右
            }
        }

        function playStageMusic(index) {
            if (this.currentMusic) {
                this.currentMusic.stop();
            }
            this.currentMusic = this.stageMusic[index];
            this.currentMusic.play();
        }
        function updateBossHealthBar(currentHealth) {
            const barWidth = 300;
            const ratio = Phaser.Math.Clamp(currentHealth / bossMaxHealth, 0, 1);
            bossHealthBar.width = barWidth * ratio;

            if (ratio <= 0) {
                bossHealthBar.visible = false;
                bossHealthBarBg.visible = false;
            } else {
                bossHealthBar.visible = true;
                bossHealthBarBg.visible = true;
            }
        }
        //boss死亡
        function playBossDeathEffect(scene, x, y) {
            // 閃光效果
            const flash = scene.add.circle(x, y, 100, 0xffffff, 1).setDepth(10);
            scene.tweens.add({
                targets: flash,
                scale: 2,
                alpha: 0,
                duration: 300,
                onComplete: () => flash.destroy()
            });

            // 鏡頭震動
            scene.cameras.main.shake(300, 0.01);

            BossDeathSound.play();

        }
        function playBoomEffect(scene) {


            // 閃光效果
            flash = scene.add.circle(player.x, player.y, 100, 0xffffff, 1).setDepth(10);
            scene.tweens.add({
                targets: flash,
                scale: 2,
                alpha: 0,
                duration: 200,
                onComplete: () => flash.destroy()
            });
            const particles = scene.add.particles(player.x, player.y, 'cParticle', {
                speed: { min: 100, max: 300 },
                angle: { min: 0, max: 360 },
                scale: { start: 0.1, end: 0 },
                alpha: { start: 1, end: 0 },
                maxParticles: 100,
                lifespan: 2000,
                quantity: 10,
                blendMode: 'ADD'
            });

            BossDeathSound.play();

        }
        function BossEffect(scene, x, y, boss) {
            // 閃光效果
            const particles = scene.add.particles(x, y, 'cParticle', {
                speed: { min: 100, max: 300 },
                angle: { min: 0, max: 360 },
                scale: { start: 0.1, end: 0 },
                alpha: { start: 1, end: 0 },
                maxParticles: 20,
                lifespan: 500,
                quantity: 10,
                blendMode: 'ADD'
            });
            scene.tweens.add({
                targets: boss,
                tint: 0xff0000,       // 變紅
                duration: 100,
                yoyo: true,           // 再變回原色
                repeat: 2             // 閃爍兩次
            });
            // 鏡頭震動
            scene.cameras.main.shake(200, 0.01);
            // 音效（若有）
            //  if (scene.sound) {
            BossCSound.play();
            // }
        }

        function showRestartText() {
            restartText = this.add.text(400, 400, '你已陣亡，點擊這裡重新開始', {
                fontFamily: 'Arial',
                fontSize: '32px',
                color: '#ff0000',
                backgroundColor: '#000000aa',
                padding: { x: 10, y: 10 },
            }).setOrigin(0.5).setInteractive();
            fabg = this.add.image(400,200,'fabg').setOrigin(0.5).setDepth(-1).setScale(0.3);

            restartText.on('pointerover', () => {
                restartText.setStyle({ color: '#ffff00' });
            });
            restartText.on('pointerout', () => {
                restartText.setStyle({ color: '#ff0000' });
            });

            restartText.on('pointerdown', () => {
                restartStage.call(this);
            });
        }

        function restartStage() {
            clearAllTimers();
            stopAllBoss3Timers();
            clearBoss2Timers();
            clearAllBullets();
            boss2Phase = 0;
            boss3Phase = 0;
            boss3MoveActive = false;
            bossHealthBar.visible = false;
            bossHealthBarBg.visible = false;
            a = 0;
            score = 0;
            boss1bg.stop();
            boss2bg.stop();
            boss3bg.stop();
            allSprites = [];
            if (boss3Clones && boss3Clones.length > 0) {
                boss3Clones.forEach(clone => {
                    if (clone && clone.active) {
                        clone.destroy();
                    }
                });
                boss3Clones = [];
            }
            if (scoreText) {
                scoreText.setText('Score: 0');
            }
            // —— 1. 销毁「重新开始」文字 —— 
            if (restartText) {
                restartText.destroy();
                restartText = null;
                fabg.destroy();
            }

            // —— 2. 恢复物理系统 & Tween —— 
            // 在 onPlayerHit() 里我们做了 this.physics.pause()，这里必须 resume()
            this.physics.resume();
            // 把所有残留的 Tween 都杀掉，避免动画残留导致碰撞、坐标不对
            this.tweens.killAll();

            // —— 3. 重播本关普通 BGM —— 
            if (this.currentMusic) {
                this.currentMusic.stop();
            }
            playStageMusic.call(this, stageIndex);

            // —— 4. 清场：所有子弹 / 怪物 / Boss / 道具 / 特效 —— 
            // 4.1 清除所有子弹群组（玩家子弹 + 怪物子弹 + 特殊弹组）
            if (playerBullets) playerBullets.clear(true, true);
            if (bullets) bullets.clear(true, true);
            if (bulletGroup) bulletGroup.clear(true, true);
            if (markExplodeGroup) markExplodeGroup.clear(true, true);
            if (spearGroup) spearGroup.clear(true, true);

            // 4.2 清除所有怪物
            if (enemies) enemies.clear(true, true);

            // 4.3 如果有正在场上的 Boss，要一并销毁
            if (boss1) { boss1.destroy(); boss1 = null; }
            if (boss2) { boss2.destroy(); boss2 = null; }
            if (boss3) { boss3.destroy(); boss3 = null; }

            // 4.4 清除掉任何残留的道具
            if (this.items) this.items.clear(true, true);

            // —— 5. 重置玩家 —— 
            hearts = maxHearts;
            updateHearts();

            // 把玩家的 tint、透明度、位置都恢复到初始状态
            player.clearTint();
            player.setAlpha(1);
            player.setPosition(400, 900);
            player.setVisible(true);
            // 确保 physics body 可用
            player.body.enable = true;
            // 重新设置 collideWorldBounds，防止边界检测失效
            player.setCollideWorldBounds(false);

            // —— 6. 重置全局标记，让「小怪→Boss→下一关」能重新正常流程 —— 
            this.bossBeingSpawned = false;
            lastWaveCleared = false;

            // —— 7. 重置 waveIndex，使本关从第 1 波开始 —— 
            waveIndex = 0;

            // —— 8. 让摄像机、背景等都回到初始位置 —— 
            // 如果你有对 camera 或 this.bg 做过 tween，要把它们的滚动重置
            this.cameras.main.scrollX = 0;
            this.cameras.main.scrollY = 0;
            if (this.bg) {
                this.bg.tilePositionY = 0;
            }
            if (this.mark) {
                this.mark.setVisible(true);
            }

            // —— 9. 恢复玩家控制 & 触发入场动画（可选） —— 
            this.controlEnabled = false;
            this.physics.world.enable(player); // 确保玩家物理再次生效

            // 如果想要重现入场 Tween，让玩家从 y=900 动画到 y=680：
            this.tweens.add({
                targets: player,
                y: 680,
                duration: 1000,
                ease: 'Quart.easeInOut',
                onComplete: () => {
                    player.setCollideWorldBounds(true);
                    this.controlEnabled = true;
                }
            });

            // —— 10. 生成本关第 1 波 —— 
            const curStage = stages[stageIndex];
            spawnWave.call(this, curStage.waves[waveIndex]);
            waveIndex++;
        }
        function reduceBossHealth(amount, scene) {
            if (boss1 && boss1.active) {
                boss1health -= amount;
                if (boss1health < 0) boss1health = 0;

            } else if (boss2 && boss2.active) {
                boss2Health -= amount;
                if (boss2Health < 0) boss2Health = 0;

                updateBoss2Behavior(scene);
            } else if (boss3 && boss3.active) {
                boss3Health -= amount;
                if (boss3Health < 0) boss3Health = 0;

                updateBoss3Behavior(scene);
            }
        }
        function showUpgradeOptions() {
            spreadShot.setVisible(true);
            missileUpgrade.setVisible(true);
            rapidFire.setVisible(true);
            powertext.setVisible(true);
        }
        // showUpgradeMenu 用一次就顯示三個選項
        function showUpgradeMenu(scene, onSelect) {
            // 先呼叫 pauseGame，確保背景、敵人、子彈等都暫停
            pauseGame(scene);

            // 預設文字樣式
            const styleTitle = { font: "28px Arial", fill: "#ffff00" };
            const styleOption = { font: "24px Arial", fill: "#ffffff" };

            // 在畫面中央顯示一個半透明遮罩，讓後面的都不可點（可選）
            // 這裡只示範純文字，若要可加個黑色半透明方塊：
            // const mask = scene.add.rectangle(400, 400, 800, 800, 0x000000, 0.5).setDepth(1000);

            // 標題
            upgradeTextTitle = scene.add.text(400, 200, "選擇一項能力強化", styleTitle)
                .setOrigin(0.5)
                .setDepth(1100);

            // 三個選項文字，各自設為可點按
            upgradeChoicePrimary = scene.add.text(400, 260, "▶ 主子彈 +1", styleOption)
                .setOrigin(0.5)
                .setInteractive()
                .setDepth(1100);

            upgradeChoiceSecondary = scene.add.text(400, 300, "▶ 副子彈 +1", styleOption)
                .setOrigin(0.5)
                .setInteractive()
                .setDepth(1100);

            upgradeChoiceRapid = scene.add.text(400, 340, "▶ 提高連射速度", styleOption)
                .setOrigin(0.5)
                .setInteractive()
                .setDepth(1100);

            // 滑鼠移上變色、移出還原
            [upgradeChoicePrimary, upgradeChoiceSecondary, upgradeChoiceRapid].forEach(txt => {
                txt.on('pointerover', () => txt.setStyle({ fill: "#ffff00" }));
                txt.on('pointerout', () => txt.setStyle({ fill: "#ffffff" }));
            });

            // 每個點擊回調：先把三個選項文字都 destroy，再呼叫 onSelect 並 resumeGame
            upgradeChoicePrimary.on('pointerdown', () => {
                // apply 主子彈 +1
                onSelect("primary");
                closeUpgradeMenu(scene);
            });
            upgradeChoiceSecondary.on('pointerdown', () => {
                onSelect("secondary");
                closeUpgradeMenu(scene);
            });
            upgradeChoiceRapid.on('pointerdown', () => {
                onSelect("rapid");
                closeUpgradeMenu(scene);
            });
        }

        // 關閉並清理剛剛的 UI
        function closeUpgradeMenu(scene) {
            if (upgradeTextTitle) {
                upgradeTextTitle.destroy();
                upgradeTextTitle = null;
            }
            if (upgradeChoicePrimary) {
                upgradeChoicePrimary.destroy();
                upgradeChoicePrimary = null;
            }
            if (upgradeChoiceSecondary) {
                upgradeChoiceSecondary.destroy();
                upgradeChoiceSecondary = null;
            }
            if (upgradeChoiceRapid) {
                upgradeChoiceRapid.destroy();
                upgradeChoiceRapid = null;
            }

            // 最後呼叫 resumeGame，讓遊戲繼續
            resumeGame(scene);
        }
        function showMainMenu(scene) {
            // 1. 先把遊戲畫面裡所有「與關卡流程相關」的物件都隱藏或 destroy
            //    包括玩家、背景、敵人群、子彈群、Boss、道具、血條等等
            //    你可以一一檢查並 destroy 或 setVisible(false)
            if (scene.player) scene.player.setVisible(false);
            if (scene.bg) scene.bg.setVisible(false);
            if (scene.mark) scene.mark.setVisible(false);
            if (scene.enemies) scene.enemies.clear(true, true);
            if (scene.bullets) scene.bullets.clear(true, true);
            if (scene.playerBullets) scene.playerBullets.clear(true, true);
            if (scene.bulletGroup) scene.bulletGroup.clear(true, true);
            if (scene.bulletGroup2) scene.bulletGroup2.clear(true, true);
            if (scene.bulletGroup3) scene.bulletGroup3.clear(true, true);
            if (scene.items) scene.items.clear(true, true);
            if (scene.markGroup) scene.markGroup.clear(true, true);
            if (scene.markExplodeGroup) scene.markExplodeGroup.clear(true, true);
            if (scene.chainGroup) scene.chainGroup.clear(true, true);
            if (scene.chainHeadGroup) scene.chainHeadGroup.clear(true, true);
            if (scene.spearGroup) scene.spearGroup.clear(true, true);
            // 刪除所有 Boss
            if (scene.boss1) { scene.boss1.destroy(); scene.boss1 = null; }
            if (scene.boss2) { scene.boss2.destroy(); scene.boss2 = null; }
            if (scene.boss3) { scene.estroy(); scene.boss3 = null; }
            // 清除血條顯示
            if (scene.bossHealthBar) scene.bossHealthBar.setVisible(false);
            if (scene.bossHealthBarBg) scene.bossHealthBarBg.setVisible(false);

            // 2. 把 Tween、Timer、Physics 都恢復到初始（因為從關卡過來可能已經 pause）
            resumeGame(scene);

            // 3. 重置全域關卡索引、波次、player 狀態、分數等等
            stageIndex = 0;
            waveIndex = 0;
            scene.bossBeingSpawned = false;
            lastWaveCleared = false;
            scene.controlEnabled = false;
            hearts = maxHearts;
            updateHearts();
            scene.score = 0;
            if (scene.scoreText) scene.scoreText.setText('Score: 0');
            // reset player 位置
            if (scene.player) {
                scene.player.setPosition(400, 900);
                scene.player.clearTint();
                scene.player.setAlpha(1);
                scene.player.setVisible(true);
                scene.player.body.enable = true;
                scene.player.setCollideWorldBounds(false);
            }

            // 4. 刪除任何存在的「升級選單」UI 元素
            if (upgradeTextTitle) {
                upgradeTextTitle.destroy();
                upgradeTextTitle = null;
            }
            if (upgradeChoicePrimary) {
                upgradeChoicePrimary.destroy();
                upgradeChoicePrimary = null;
            }
            if (upgradeChoiceSecondary) {
                upgradeChoiceSecondary.destroy();
                upgradeChoiceSecondary = null;
            }
            if (upgradeChoiceRapid) {
                upgradeChoiceRapid.destroy();
                upgradeChoiceRapid = null;
            }

            // 5. 顯示主畫面 UI
            UIBG = scene.add.image(600, 400, 'UIBG')
                .setOrigin(0.5)
                .setDepth(-1)
                .setScale(1);

            startButton = scene.add.text(600, 460, '開始', {
                fontFamily: 'Arial',
                fontSize: '36px',
                color: '#ffffff',
                backgroundColor: '#4444aa',
                padding: { x: 20, y: 10 },
            }).setOrigin(0.5).setInteractive();

            [startButton].forEach(button => {
                button.on('pointerover', () => button.setStyle({ backgroundColor: '#6666cc' }));
                button.on('pointerout', () => button.setStyle({ backgroundColor: '#4444aa' }));
            });

            // 6. 給 Start 按鈕重新綁定「點擊 → 先彈升級選單再開始遊戲」
            startButton.on('pointerdown', () => {
                // 隱藏主畫面 UI
                UIBG.destroy();
                startButton.destroy();

                // 顯示玩家生命 / 炸彈 / P 點 UI
                for (let i = 0; i < maxHearts; i++) {
                    let heart = scene.add.image(30 + i * 32, 30, 'heart')
                        .setScrollFactor(0)
                        .setScale(0.7);
                    heartIcons.push(heart);
                }
                uiText.bombs = scene.add.text(20, 70, `BOMB: ${bombs}/${maxBombs}`, { font: "18px Arial", fill: "#ffffff" });
                uiText.p = scene.add.text(20, 100, `P點數: ${scoreP}`, { font: "18px Arial", fill: "#ffffff" });

                // 先顯示背景／玩家
                scene.bg.setVisible(true);
                scene.player.setVisible(true);
                scene.mark.setVisible(true);

                // 暫停遊戲
                pauseGame(scene);

                // 彈出一次升級選單
                showUpgradeMenu(scene, (choice) => {
                    // 依 choice 給予一次升級
                    if (choice === "primary") {
                        playerUpgrades.spread += 1;
                        toolLeft.setVisible(true);
                        toolRight.setVisible(true);
                    } else if (choice === "secondary") {
                        playerUpgrades.missileCount += 1;
                        playerUpgrades.missileUpgradeLevel += 1;
                    } else if (choice === "rapid") {
                        fireSpeed -= 50;
                    }

                    // 升級選完後 (closeUpgradeMenu 內部已呼 resumeGame)，
                    // 再跑「玩家入場動畫 → 背景滑動 → 第 1 波」
                    scene.physics.world.enable(scene.player);
                    scene.tweens.add({
                        targets: scene.player,
                        y: 680,
                        duration: 3000,
                        ease: 'Quart.easeInOut',
                        onComplete: () => {
                            scene.player.setCollideWorldBounds(true);
                            scene.controlEnabled = true;
                        }
                    });
                    scene.tweens.add({
                        targets: scene.bg,
                        tilePositionY: scene.bg.tilePositionY - 1200,
                        duration: 3000,
                        ease: 'Sine.easeInOut',
                        onComplete: () => {
                            spawnWave.call(scene, waveDataone[waveIndex]);
                            waveIndex++;
                        }
                    });
                });
            });
        }
        function updateHearts() {
            heartIcons.forEach((icon, index) => {
                icon.setVisible(index < hearts); // 只顯示小於目前血量數的圖示
            });
        }
        function handleItem(player, item) {
            const type = item.getData('type'); // 取得道具類型（例如：bomb、new、p）
            item.destroy(); // 收取道具後銷毀該道具物件

            if (type === 'bomb' && bombs < maxBombs) { // 如果是炸彈道具且未達炸彈上限
                bombs++; // 炸彈數量增加1
                uiText.bombs.setText(`BOMB: ${bombs}/${maxBombs}`); // 更新畫面上炸彈數量文字
            } else if (type === 'new' && hearts < maxHearts) { // 如果是補血道具且血量未滿
                hearts++; // 血量增加1
                updateHearts(); // 更新畫面上愛心顯示
            } else if (type === 'p') { // 如果是P點數道具
                scoreP++; // P點數增加1
                uiText.p.setText(`P點數: ${scoreP}`); // 更新P點數文字
            }
        }
    </script>
    <!-- 變數 -->
    <script src="./setting.js"></script>
    <!-- 玩家 -->
    <script src="./player.js"></script>
    <!-- 小怪 -->
    <script src="./one.js"></script>
    <script src="./two.js"></script>
    <script src="./three.js"></script>
    <script src="./bossJS/boss1.js"></script>
    <script src="./bossJS/boss2.js"></script>
    <script src="./bossJS/boss3.js"></script>
</body>

</html>